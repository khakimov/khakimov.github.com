<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: instagram | Doing things]]></title>
  <link href="http://khakimov.github.com/blog/categories/instagram/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2012-12-09T23:18:29-08:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to make new instagram's friends with Ruby]]></title>
    <link href="http://khakimov.github.com/blog/2012/03/09/how-to-make-new-instagrams-friends-with-ruby/"/>
    <updated>2012-03-09T11:09:00-08:00</updated>
    <id>http://khakimov.github.com/blog/2012/03/09/how-to-make-new-instagrams-friends-with-ruby</id>
    <content type="html"><![CDATA[<p>I moved to Palo Alto few month ago from LA and realized that I didn't know anybody in Bay Area. I was looking for a new friends ;) I had one and his name is Ruby, so we decided to write some code which will help me to make new friends in instagram. First of all it was a good practice and also interesting task where you can easily get feedback from action (code and you get friends).</p>

<h2>Instagram</h2>

<p>It’s a fast, beautiful and fun way to share your life with friends through a series of pictures.</p>

<p>Snap a photo with your iPhone, choose a filter to transform the look and feel, send to Facebook, Twitter or Flickr – it’s all as easy as pie. It’s photo sharing, reinvented.</p>

<p>Instagram has <a href="http://instagram.com/developer/">API</a> which allows you to do anything you want - search users, their likes, relationships, comments, tags, locations and geo.</p>

<h2>Idea</h2>

<p>The idea was simple - to find by tags people who posted their photos from San Francisco and Bay Area (#sanfrancisco, #bayarea, #paloalto, #mountainview and so on). What will I get? I will get the users who probably living there and then I will just follow them and probably they will follow me back. So I will get followers from Bay Area and will able to talk through my pics with people who are living in Bay Area. As example, I can ask about some nice event or party and maybe somebody will share some or invite ;) Stupid isn't? But it works!</p>

<h2>Code</h2>

<p>``` ruby Let me introduce myself ;)
require 'open-uri'
require 'uri'
require 'net/http'
require 'net/https'
require 'json'</p>

<p>ACCESS_TOKEN = "put_yours_access_token_there"</p>

<p>def fetch(url, response = '')
  begin</p>

<pre><code>open(url) { |f| f.each_line {|line| response += line } }
return JSON.parse(response) 
</code></pre>

<p>  rescue OpenURI::HTTPError</p>

<pre><code>nil
</code></pre>

<p>  end
end</p>

<p>def get_followers
  url = "https://api.instagram.com/v1/users/self/followed-by?access_token=#{ACCESS_TOKEN}"
  next_url = fetch(url)['pagination']['next_url']
  followers = {}</p>

<p>  while next_url</p>

<pre><code>result = fetch(next_url)
next_url = result['pagination']['next_url']
result['data'].each { |data| followers.merge!(data['username'] =&gt; data['id'])}
p followers.count
</code></pre>

<p>  end
  return followers
end</p>

<p>def unfollow_mutual_friends(followers)
  url = "https://api.instagram.com/v1/users/self/follows?access_token=#{ACCESS_TOKEN}"
  next_url = fetch(url)['pagination']['next_url']</p>

<p>  while next_url</p>

<pre><code>result = fetch(next_url)
next_url = result['pagination']['next_url']

result['data'].each { |data| 
  unless followers.include?(data['username'])
    uri = URI.parse("https://api.instagram.com/v1/users/#{data['id']}/relationship?access_token=#{ACCESS_TOKEN}")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true
    http.verify_mode = OpenSSL::SSL::VERIFY_NONE

    request = Net::HTTP::Post.new(uri.path)
    request.set_form_data("action" =&gt; "unfollow", "access_token" =&gt; "#{ACCESS_TOKEN}")

    response = http.request(request)
    p "#{data['username']} code #{response.code}"
  end
  }
</code></pre>

<p>  end
end</p>

<p>def find_users_by_tag(tag)
  url = "https://api.instagram.com/v1/tags/#{tag}/media/recent?access_token=#{ACCESS_TOKEN}"
  next_url = fetch(url)['pagination']['next_url']
  users = {}</p>

<p>  while next_url</p>

<pre><code>result = fetch(next_url)
next_url = result['pagination']['next_url']
result['data'].each { |data| users.merge!(data['user']['username'] =&gt; data['user']['id']) }
# people who likes pics with this tag
#data['likes']['data'].each { |likes| @users.merge!(likes['username'] =&gt; likes['id']) } 
p users.count
</code></pre>

<p>  end
end</p>

<p>def follow_users(potential_friends)
  potential_friends.each { |username, id|</p>

<pre><code>uri = URI.parse("https://api.instagram.com/v1/users/#{id}/relationship?access_token=#{ACCESS_TOKEN}")
http = Net::HTTP.new(uri.host, uri.port)
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE

request = Net::HTTP::Post.new(uri.path)
request.set_form_data("action" =&gt; "follow", "access_token" =&gt; "#{ACCESS_TOKEN}")

response = http.request(request)
puts "#{username} added" if response.code == "200"
</code></pre>

<p>  }
end
```</p>

<p>So, if we want to find and follow people who tagged their pics with tag #paloalto:</p>

<p><code>ruby find users by tag #paloalto and follow them
potential_friends = find_users_by_tag("paloalto")
follow_user(potential_friends)
</code></p>

<p>To unfollow people we have to know who is following us and then unfollow who is not.</p>

<p><code>ruby unfollow !mutual people
followers = get_followers
unfollow_mutual_friends(followers)
</code></p>

<p>so, that's it. Of course this is my ugly code has to be improved and will be better to add some features like save followers list, save position of finding user by tag (disconnect or something - save the last url and next run will be continue parsing from this position). Anyway, this is just simple ruby script (heh, I've rewritten few time, it was good practice but still code look ugly I know).</p>

<p>ps: proof
<img src="http://pix.am/HIiH.png" alt="proof" /></p>
]]></content>
  </entry>
  
</feed>
