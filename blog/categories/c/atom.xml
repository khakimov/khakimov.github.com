<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c | Doing things]]></title>
  <link href="http://khakimov.github.com/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2012-11-15T17:14:49-08:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pthreads and Shared Variables]]></title>
    <link href="http://khakimov.github.com/blog/2012/10/19/pthreads-and-shared-variables/"/>
    <updated>2012-10-19T16:17:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/10/19/pthreads-and-shared-variables</id>
    <content type="html"><![CDATA[<p>I started yesterday with a ascii picture that shows how threads looks like. Now I want to add variable "<strong>a</strong>" into each thread:</p>

<p>```
  Master Thread</p>

<pre><code>    |
</code></pre>

<p>unsigned int a = 0;</p>

<pre><code>    |
    |        create workers with pthread_create()
    |
  // \\      workers start up
 / | | \
 | | | |
 a a a a     workers do a++ in loop jobs (thread routine)
 | | | |
 \ \ / /
  \\ //      workers terminate
    |
    |        join workers with pthread_join()
    |
</code></pre>

<p>  Master Thread
```</p>

<p>This picture shows the possibility of synchronization errors when every thread has same access to variable <strong>a</strong>. Let code some example of this problem:</p>

<p>```c shared.c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;pthread.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>define N 100000</h1>

<p>void <em>job(void </em>arg);</p>

<p>unsigned int a = 0;</p>

<p>int main()
{
   pthread_t tid1, tid2;
   pthread_create(&amp;tid1, NULL, job, NULL);
   pthread_create(&amp;tid2, NULL, job, NULL);</p>

<p>   pthread_join(tid1, NULL);
   pthread_join(tid2, NULL);</p>

<p>   if(a != (N * 2))</p>

<pre><code>  printf("Nope! a = %d\n", a);
</code></pre>

<p>   else</p>

<pre><code>  printf("OK! a = %d\n", a);
</code></pre>

<p>   exit(0);
}</p>

<p>void <em>job(void </em>arg)
{
   int i;
   for(i = 0; i &lt; N; i++)</p>

<pre><code>  a++;
</code></pre>

<p>   return NULL;
}
```</p>

<p><code>
gcc shared.c -o shared &amp;&amp; ./shared
Nope! a = 161406
./shared
Nope! a = 162099
./shared
Nope! a = 133299
</code></p>

<p>hmm, strange, isn't? It happens because of improperly synchronization.</p>

<p><code>
_job:
0000000100000e80  pushq %rbp
0000000100000e81  movq  %rsp,%rbp
0000000100000e84  movq  %rdi,0xf8(%rbp)
0000000100000e88  movl  $0x00000000,0xe4(%rbp) ; i = 0
0000000100000e8f  jmp 0x100000ea9
; loop
0000000100000e91  movl  0x000001e1(%rip),%eax ; our global a
0000000100000e97  addl  $0x01,%eax            ; a++
0000000100000e9a  movl  %eax,0x000001d8(%rip) ; save
0000000100000ea0  movl  0xe4(%rbp),%eax       
0000000100000ea3  addl  $0x01,%eax            ; i++
0000000100000ea6  movl  %eax,0xe4(%rbp)       
0000000100000ea9  movl  0xe4(%rbp),%eax
0000000100000eac  cmpl  $0x0001869f,%eax      ; i &lt; 100000
0000000100000eb1  jle 0x100000e91             ; check and jump
; jle - less or equal
0000000100000eb3  movq  $0x00000000,0xe8(%rbp)
0000000100000ebb  movq  0xe8(%rbp),%rax
0000000100000ebf  movq  %rax,0xf0(%rbp)
0000000100000ec3  movq  0xf0(%rbp),%rax
0000000100000ec7  popq  %rbp
0000000100000ec8  ret
</code></p>

<p>That is how our loop in function <strong>job</strong> looks in machine code (otool -Vt ./shared). And as you can also see, each thread load/save data from same memory address 0x000001e1(%rip), that's why we always get wrong answer, because thread compete with each other and improperly. How to fix it? We have to lock variable, change it and then unlock it to allow other threads to change it:</p>

<p>```c shared2.c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;pthread.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>define N 100000</h1>

<p>void <em>job(void </em>arg);</p>

<p>unsigned int a = 0;
pthread_mutex_t mutexA;</p>

<p>int main()
{
   pthread_t tid1, tid2;</p>

<p>   pthread_mutex_init(&amp;mutexA, NULL);</p>

<p>   pthread_create(&amp;tid1, NULL, job, NULL);
   pthread_create(&amp;tid2, NULL, job, NULL);</p>

<p>   pthread_join(tid1, NULL);
   pthread_join(tid2, NULL);</p>

<p>   if(a != (N * 2))</p>

<pre><code>  printf("Nope! a = %d\n", a);
</code></pre>

<p>   else</p>

<pre><code>  printf("OK! a = %d\n", a);
</code></pre>

<p>   pthread_mutex_destroy(&amp;mutexA);
   exit(0);
}</p>

<p>void *
job(void *arg)
{
   int i;
   for(i = 0; i &lt; N; i++) {</p>

<pre><code>  /*
  Lock mutex prior to updating the value in the shared
  variable and unlock it upon updating. 
  */

  pthread_mutex_lock (&amp;mutexA);
  a++;
  pthread_mutex_unlock(&amp;mutexA);
</code></pre>

<p>   }
   return NULL;
}
```</p>

<p>Now it looks much better!</p>

<p><code>
gcc shared2.c -o shared2 &amp;&amp; ./shared2
OK! a = 200000
./shared2
OK! a = 200000
./shared2
OK! a = 200000
</code></p>

<p>That is it! Now we can use shared variables in our threads and build something interesting. In next post I will write about <strong>thread-safety</strong> and how to write thread-safe function.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C Posix Threads boot camp]]></title>
    <link href="http://khakimov.github.com/blog/2012/10/18/c-posix-threads-boot-camp/"/>
    <updated>2012-10-18T19:03:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/10/18/c-posix-threads-boot-camp</id>
    <content type="html"><![CDATA[<p>The White Rabbit put on his spectacles,
"Where shall I begin, please your Majesty?" he asked.
"Begin at the beginning," the King said, very gravely,
"and go on till you come to the end: then stop."</p>

<p>Lewis Carroll, Alice's Adventures in Wonderland</p>

<p>This post is about threads and the reason why I'm writing this because I want to know more and more about thread, but before that I have to repeat and refresh everything about this huge topic. I saw funny qoute about the process of learning and doing concurrency code</p>

<p>"i don't know threads!," then "I got it! I know how it works!," then "I don't know threads!" and so on.</p>

<p>So, I'm going to use here the threads model that is called POSIX threads or Pthreads. Brief story you can read on wikipedia (http://en.wikipedia.org/wiki/POSIX_Threads)[here.] The main thing that its available on many Unix-like OS, and if you are using mac or linux I'm sure you have file name pthread.h in your libraries directory. The best to start is write "Hello World" with threads.</p>

<pre><code>  Master Thread
        |
        |        create workers with pthread_create()
        |
      // \\      workers start up
     / | | \
     | | | |
     | | | |     workers do their jobs (thread routine)
     | | | |
     \ \ / /
      \\ //      workers terminate
        |
        |        join workers with pthread_join()
        |
  Master Thread
</code></pre>

<p>```c hello.c
/<em> posix thread </em>/</p>

<h1>include &lt;pthread.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>void <em>thread_routine(void </em>arg);</p>

<p>int main()
{</p>

<p>   /<em>
   local variable which will be used to store the thread ID of
   the peer thread
   </em>/</p>

<p>   pthread_t tid;</p>

<p>   /<em>
   pthread_create function creates a new thread (obvious)
   and runs the thread_routine in the context of the new thread
   with an input arg NULL (just after thread_routine). In our case
   we just run thread_routine without any argument.
   when the call to pthread_create returns - tid contains the ID
   the new thread
   </em>/</p>

<p>   pthread_create(&amp;tid, NULL, thread_routine, NULL);</p>

<p>   /<em>
   the main thread waits for the peer thread to terminate with
   the call pthread_join.
   </em>/
   pthread_join(tid, NULL);
   exit(0);
}</p>

<p>void <em>thread_routine(void </em>arg)
{
   printf("Hello world!\n");
   return NULL;
}
```
compile and run</p>

<p>○ gcc hello.c -o hello &amp;&amp; ./hello
Hello world!</p>

<p>Let's play a little bit with pthreads, you will see this is much easier than it looks like now.</p>

<p>```c hello2.c</p>

<h1>include &lt;pthread.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>void <em>thread_routine(void </em>arg);</p>

<p>int main()
{
   pthread_t tid;
   pthread_create(&amp;tid, NULL, thread_routine, NULL);
   printf("[1] I've create a thread %ld\n", (long)tid);
   printf("[2] pthread_join and wait till its finish his job\n");
   pthread_join(tid, NULL);
   printf("[6] Thread %ld terminated. Now in main!\n", (long)tid);
   printf("[7] Time to clean up and exit. Bye!\n");
   exit(0);
}</p>

<p>void <em>thread_routine(void </em>arg)
{</p>

<pre><code>int i = 1000000;
char dot = '.';
printf("\t[3] I'm inside the thread %ld\n", (long)pthread_self());
printf("\t[4] Hello world! I'm working...\n");
while(i != 0)
    printf("\t%d\r", i--);
printf("\t[5] Done! Returning to the main thread!\n");
return NULL;
</code></pre>

<p>}
```
○ gcc hello2.c -o hello2 &amp;&amp; ./hello2</p>

<p><code>
[1] I've create a thread 4513894400
  [3] I'm inside the thread 4513894400
[2] pthread_join and wait till its finish his job
  [4] Hello world! I'm working...
  [5] Done! Returning to the main thread!
[6] Thread 4513894400 terminated. Now in main!
[7] Time to clean up and exit. Bye!
</code></p>

<p>I've added while loop into thread_routine function to show how pthread_join works (waits for thread termination). Notice that the pthread_join function can only wait for a specific thread to terminate. Let's try to make 5 thread and see how it works:</p>

<p>```c</p>

<h1>include &lt;pthread.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>define NUM_THREADS 5</h1>

<p>void <em>thread_routine(void </em>arg);</p>

<p>int main()
{
   pthread_t tid[NUM_THREADS];
   int i;</p>

<pre><code>for(i = 0; i &lt; NUM_THREADS; i++) {
    pthread_create(&amp;tid[i], NULL, thread_routine, (void *) &amp;i);
    printf("[t %d][1] I've create a thread %ld\n", i, (long)tid);
}

for(i = 0; i &lt; NUM_THREADS; i++) {
    printf("[t %d][2] pthread_join and wait till its finish his job\n", i);
    pthread_join(tid[i], NULL);
    printf("[t %d][6] Thread %ld terminated!\n", i, (long)tid[i]);
}
printf("[7] Time to clean up and exit. Bye!\n");
exit(0);
</code></pre>

<p>}</p>

<p>void <em>thread_routine(void </em>arg)
{</p>

<pre><code>int threadNum = *(int *)arg;
int i = 100000;
char dot = '.';
printf("\t[t %d]\t[3] I'm inside the thread %ld\n", threadNum, (long)pthread_self());
// printf("\t[4] Hello world! I'm working...\n");
while(i != 0) {
    printf("\v%*d\r", threadNum*15, i--);
}
printf("\t[t %d][5] Done! Returning to the main thread!\n", threadNum);
return NULL;
</code></pre>

<p>}
```</p>

<p>Looks like matrix in my terminal.</p>

<p><img src="http://pix.am/urR5.png" alt="" /></p>

<p>Before we start talking about <strong>detaching thread</strong>, you can play with this code and threads, if you don't understand something try to change code and see how it will work. In my case was a problem with pthread_join, but after couple examples I've realized how it works and moved on.</p>

<p>By default, threads created joinable and joinable thread can be reaped and killed by other threads. On other case, detached thread cannot be reaped or killed by other threads. Its memory resources are freed automatically by the system when it terminates. To "detach" the thread we have to use <strong>pthread_detach</strong> function.</p>

<p>```c</p>

<h1>include &lt;pthread.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;strings.h></h1>

<h1>include &lt;sys/socket.h></h1>

<h1>include &lt;arpa/inet.h></h1>

<h1>include &lt;sys/types.h></h1>

<p>void <em>thread_routine(void </em>arg);</p>

<p>int open_listenfd(int port);</p>

<p>int main()
{</p>

<pre><code>pthread_t tid;
int *connfd_p, listenfd, port, clientlen = sizeof(struct sockaddr_in);
struct sockaddr_in clientaddr;

port = 1337;
listenfd = open_listenfd(port);
while(1) {
    connfd_p = malloc(sizeof(int));
    *connfd_p = accept(listenfd, (void *) &amp;clientaddr, &amp;clientlen);
    pthread_create(&amp;tid, NULL, thread_routine, connfd_p);
}
exit(0);
</code></pre>

<p>}</p>

<p>int
open_listenfd(int port)
{</p>

<pre><code>int listenfd, optval = 1;
struct sockaddr_in serveraddr;

if ((listenfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0)
    return -1;

if(setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (const void *)&amp;optval, sizeof(int)) &lt; 0)
    return -2;

bzero((char *)&amp;serveraddr, sizeof(serveraddr));
serveraddr.sin_family = AF_INET;
serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);
serveraddr.sin_port = htons((unsigned short) port);
if(bind(listenfd, (void *)&amp;serveraddr, sizeof(serveraddr)) &lt; 0)
    return -3;

if(listen(listenfd, 1024) &lt; 0)
    return -4;

return listenfd;
</code></pre>

<p>}</p>

<p>void<em>
thread_routine(void </em>arg)
{</p>

<pre><code>int connfd = *((int *) arg);
pthread_detach(pthread_self());
printf("New incoming connection...\n");
int i = 1000000;
while(i != 0)
    printf("%d\r", i--);
printf("Done! Close connection!\n");
free(arg);
close(connfd);
return NULL;
</code></pre>

<p>}
```</p>

<p>huh, tired a little bit, was a C maraphone for couple hours. Here is example of server which waiting connections on tcp port 1337, if somebody connected - creates new thread and start doing his job. I'll comment this code in the next post, but it works very well and now you can build your's version of web server.</p>

<p>Soon I'll write about sharing variables between threads, using mutexes and how to avoid dead locks.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C tricks]]></title>
    <link href="http://khakimov.github.com/blog/2012/08/01/c-tricks/"/>
    <updated>2012-08-01T18:25:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/08/01/c-tricks</id>
    <content type="html"><![CDATA[<p>This C code shows me a big sign <strong>"You don't know C!"</strong> =) Trying to figure out how it works. Any idea?</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>void f(int j)
{</p>

<pre><code>static void (*const ft[2])(int) = { f, exit };

printf("%d\n", j);
ft[j/1000](j + 1);
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>f(1);
</code></pre>

<p>}
```</p>

<p>or this one</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>void main(int j) {
  printf("%d\n", j);
  (&amp;main + (&amp;exit - &amp;main)*(j/1000))(j+1);
}
```</p>

<p>...will update this post with ideas ;)</p>

<p>Ok, if you are mac use then you have to use <strong>otool</strong> to view the generated assembly code. <strong>otool -tV ./test</strong></p>

<p><code>
(__TEXT,__text) section
start:
0000000100000e40        pushq   $0x00
0000000100000e42        movq    %rsp,%rbp
0000000100000e45        andq    $0xf0,%rsp
0000000100000e49        movq    0x08(%rbp),%rdi
0000000100000e4d        leaq    0x10(%rbp),%rsi
0000000100000e51        movl    %edi,%edx
0000000100000e53        addl    $0x01,%edx
0000000100000e56        shll    $0x03,%edx
0000000100000e59        addq    %rsi,%rdx
0000000100000e5c        movq    %rdx,%rcx
0000000100000e5f        jmp     0x100000e65
0000000100000e61        addq    $0x08,%rcx
0000000100000e65        cmpq    $0x00,(%rcx)
0000000100000e69        jne     0x100000e61
0000000100000e6b        addq    $0x08,%rcx
0000000100000e6f        callq   _main
0000000100000e74        movl    %eax,%edi
0000000100000e76        callq   0x100000f04     ; symbol stub for: _exit
0000000100000e7b        hlt
0000000100000e7c        nop
0000000100000e7d        nop
0000000100000e7e        nop
0000000100000e7f        nop
_f:
0000000100000e80        pushq   %rbp
0000000100000e81        movq    %rsp,%rbp
0000000100000e84        subq    $0x10,%rsp
0000000100000e88        movl    %edi,%eax
0000000100000e8a        movl    %eax,0xfc(%rbp)
0000000100000e8d        movl    0xfc(%rbp),%eax
0000000100000e90        xorb    %cl,%cl
0000000100000e92        leaq    0x0000009b(%rip),%rdx
0000000100000e99        movq    %rdx,%rdi
0000000100000e9c        movl    %eax,%esi
0000000100000e9e        movb    %cl,%al
0000000100000ea0        callq   0x100000f0a     ; symbol stub for: _printf
0000000100000ea5        movl    0xfc(%rbp),%ecx
0000000100000ea8        movl    $0x10624dd3,%esi
0000000100000ead        movl    %ecx,%eax
0000000100000eaf        imull   %esi
0000000100000eb1        movl    %edx,%eax
0000000100000eb3        movl    %eax,%ecx
0000000100000eb5        shrl    $0x1f,%ecx
0000000100000eb8        sarl    $0x06,%eax
0000000100000ebb        leal    (%rax,%rcx),%eax
0000000100000ebe        movslq  %eax,%rax
0000000100000ec1        leaq    0x00000180(%rip),%rcx
0000000100000ec8        movq    (%rcx,%rax,8),%rax
0000000100000ecc        movl    0xfc(%rbp),%ecx
0000000100000ecf        leal    0x01(%rcx),%ecx
0000000100000ed2        movl    %ecx,%edi
0000000100000ed4        call    *%rax
0000000100000ed6        addq    $0x10,%rsp
0000000100000eda        popq    %rbp
0000000100000edb        ret
0000000100000edc        nopl    0x00(%rax)
_main:
0000000100000ee0        pushq   %rbp
0000000100000ee1        movq    %rsp,%rbp
0000000100000ee4        subq    $0x20,%rsp
0000000100000ee8        movl    %edi,0xfc(%rbp)
0000000100000eeb        movq    %rsi,0xf0(%rbp)
0000000100000eef        movl    $0x00000001,%eax
0000000100000ef4        movl    %eax,%edi
0000000100000ef6        callq   _f
0000000100000efb        movl    0xec(%rbp),%eax
0000000100000efe        addq    $0x20,%rsp
0000000100000f02        popq    %rbp
0000000100000f03        ret
</code></p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/i2fhNVQPb5I?rel=0" frameborder="0" allowfullscreen></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C Pointers The Hard Way]]></title>
    <link href="http://khakimov.github.com/blog/2012/07/14/c-pointers-the-hard-way/"/>
    <updated>2012-07-14T12:57:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/07/14/c-pointers-the-hard-way</id>
    <content type="html"><![CDATA[<p>Couple weeks ago read on stackoverflow question "<a href="http://stackoverflow.com/questions/4025768/what-do-people-find-difficult-about-c-pointers">What do people find difficult about C pointers?</a>" and I found interesting answers here. One of them is:</p>

<p>  <strong>Many programmers today don't know how their machine works, just as most people who know how to drive a car don't know anything about the engine.</strong></p>

<p>I think main idea to understand how pointers work is doing some code and then debug it where you can see step by step operations with memory and can play with many variations. So, it's easy to say like read this and this and then you will understand how pointers work. In my case AHA-moment with pointers was when I found in gdb commands <strong>print</strong> (Print value of expression EXP) and <strong>x</strong> (Examine memory: x/FMT ADDRESS).</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int main()
{
  int i = 10;
  int <em>p;
  p = &i;
  printf("%d", </em>p);
}
```</p>

<p><strong>gcc -g -Wall -Werror -O0 -std=c99 -o test test.o -lm</strong></p>

<p>and then <strong>gdb ./test</strong></p>

<p>```
(gdb) break main
Breakpoint 1 at 0x100000ee4: file test.c, line 5.
(gdb) run
Starting program: /Users/khakimov/Projects/current/c/cs107/lec07/test
Reading symbols for shared libraries +........................ done</p>

<p>Breakpoint 1, main () at test.c:5
5         int i = 10;
(gdb) step
7         p = &i;
(gdb) print i
$1 = 10
(gdb) p &amp;i
$2 = (int <em>) 0x7fff5fbfef94
(gdb) print p
$4 = (int </em>) 0x7fff5fbfef94
(gdb) p *p
$5 = 10
```</p>

<p>then try to use x to examine memory:</p>

<p><code>
(gdb) x/1bt p
0x7fff5fbfef94: 00001010
(gdb) x/1bt &amp;i
0x7fff5fbfef94: 00001010
(gdb) x/1bt *&amp;p
0x7fff5fbfef94: 00001010
(gdb) x/1bt &amp;p
0x7fff5fbfef88: 10010100
</code></p>

<p>So, my suggestion is read for sure K&amp;R about pointers then open your editor, compile some code and then play with gdb till you will clear understand how and why it works. Good luck!</p>
]]></content>
  </entry>
  
</feed>
