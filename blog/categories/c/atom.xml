<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c | Doing things]]></title>
  <link href="http://khakimov.github.com/blog/categories/c/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2012-08-13T17:08:48-07:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C tricks]]></title>
    <link href="http://khakimov.github.com/blog/2012/08/01/c-tricks/"/>
    <updated>2012-08-01T18:25:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/08/01/c-tricks</id>
    <content type="html"><![CDATA[<p>This C code shows me a big sign <strong>"You don't know C!"</strong> =) Trying to figure out how it works. Any idea?</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>void f(int j)
{</p>

<pre><code>static void (*const ft[2])(int) = { f, exit };

printf("%d\n", j);
ft[j/1000](j + 1);
</code></pre>

<p>}</p>

<p>int main(int argc, char *argv[])
{</p>

<pre><code>f(1);
</code></pre>

<p>}
```</p>

<p>or this one</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<p>void main(int j) {
  printf("%d\n", j);
  (&amp;main + (&amp;exit - &amp;main)*(j/1000))(j+1);
}
```</p>

<p>...will update this post with ideas ;)</p>

<p>Ok, if you are mac use then you have to use <strong>otool</strong> to view the generated assembly code. <strong>otool -tV ./test</strong></p>

<p><code>
(__TEXT,__text) section
start:
0000000100000e40        pushq   $0x00
0000000100000e42        movq    %rsp,%rbp
0000000100000e45        andq    $0xf0,%rsp
0000000100000e49        movq    0x08(%rbp),%rdi
0000000100000e4d        leaq    0x10(%rbp),%rsi
0000000100000e51        movl    %edi,%edx
0000000100000e53        addl    $0x01,%edx
0000000100000e56        shll    $0x03,%edx
0000000100000e59        addq    %rsi,%rdx
0000000100000e5c        movq    %rdx,%rcx
0000000100000e5f        jmp     0x100000e65
0000000100000e61        addq    $0x08,%rcx
0000000100000e65        cmpq    $0x00,(%rcx)
0000000100000e69        jne     0x100000e61
0000000100000e6b        addq    $0x08,%rcx
0000000100000e6f        callq   _main
0000000100000e74        movl    %eax,%edi
0000000100000e76        callq   0x100000f04     ; symbol stub for: _exit
0000000100000e7b        hlt
0000000100000e7c        nop
0000000100000e7d        nop
0000000100000e7e        nop
0000000100000e7f        nop
_f:
0000000100000e80        pushq   %rbp
0000000100000e81        movq    %rsp,%rbp
0000000100000e84        subq    $0x10,%rsp
0000000100000e88        movl    %edi,%eax
0000000100000e8a        movl    %eax,0xfc(%rbp)
0000000100000e8d        movl    0xfc(%rbp),%eax
0000000100000e90        xorb    %cl,%cl
0000000100000e92        leaq    0x0000009b(%rip),%rdx
0000000100000e99        movq    %rdx,%rdi
0000000100000e9c        movl    %eax,%esi
0000000100000e9e        movb    %cl,%al
0000000100000ea0        callq   0x100000f0a     ; symbol stub for: _printf
0000000100000ea5        movl    0xfc(%rbp),%ecx
0000000100000ea8        movl    $0x10624dd3,%esi
0000000100000ead        movl    %ecx,%eax
0000000100000eaf        imull   %esi
0000000100000eb1        movl    %edx,%eax
0000000100000eb3        movl    %eax,%ecx
0000000100000eb5        shrl    $0x1f,%ecx
0000000100000eb8        sarl    $0x06,%eax
0000000100000ebb        leal    (%rax,%rcx),%eax
0000000100000ebe        movslq  %eax,%rax
0000000100000ec1        leaq    0x00000180(%rip),%rcx
0000000100000ec8        movq    (%rcx,%rax,8),%rax
0000000100000ecc        movl    0xfc(%rbp),%ecx
0000000100000ecf        leal    0x01(%rcx),%ecx
0000000100000ed2        movl    %ecx,%edi
0000000100000ed4        call    *%rax
0000000100000ed6        addq    $0x10,%rsp
0000000100000eda        popq    %rbp
0000000100000edb        ret
0000000100000edc        nopl    0x00(%rax)
_main:
0000000100000ee0        pushq   %rbp
0000000100000ee1        movq    %rsp,%rbp
0000000100000ee4        subq    $0x20,%rsp
0000000100000ee8        movl    %edi,0xfc(%rbp)
0000000100000eeb        movq    %rsi,0xf0(%rbp)
0000000100000eef        movl    $0x00000001,%eax
0000000100000ef4        movl    %eax,%edi
0000000100000ef6        callq   _f
0000000100000efb        movl    0xec(%rbp),%eax
0000000100000efe        addq    $0x20,%rsp
0000000100000f02        popq    %rbp
0000000100000f03        ret
</code></p>

<iframe width="560" height="315" src="http://www.youtube.com/embed/i2fhNVQPb5I?rel=0" frameborder="0" allowfullscreen></iframe>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C Pointers The Hard Way]]></title>
    <link href="http://khakimov.github.com/blog/2012/07/14/c-pointers-the-hard-way/"/>
    <updated>2012-07-14T12:57:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/07/14/c-pointers-the-hard-way</id>
    <content type="html"><![CDATA[<p>Couple weeks ago read on stackoverflow question "<a href="http://stackoverflow.com/questions/4025768/what-do-people-find-difficult-about-c-pointers">What do people find difficult about C pointers?</a>" and I found interesting answers here. One of them is:</p>

<p>  <strong>Many programmers today don't know how their machine works, just as most people who know how to drive a car don't know anything about the engine.</strong></p>

<p>I think main idea to understand how pointers work is doing some code and then debug it where you can see step by step operations with memory and can play with many variations. So, it's easy to say like read this and this and then you will understand how pointers work. In my case AHA-moment with pointers was when I found in gdb commands <strong>print</strong> (Print value of expression EXP) and <strong>x</strong> (Examine memory: x/FMT ADDRESS).</p>

<p>``` c</p>

<h1>include &lt;stdio.h></h1>

<p>int main()
{
  int i = 10;
  int <em>p;
  p = &i;
  printf("%d", </em>p);
}
```</p>

<p><strong>gcc -g -Wall -Werror -O0 -std=c99 -o test test.o -lm</strong></p>

<p>and then <strong>gdb ./test</strong></p>

<p>```
(gdb) break main
Breakpoint 1 at 0x100000ee4: file test.c, line 5.
(gdb) run
Starting program: /Users/khakimov/Projects/current/c/cs107/lec07/test
Reading symbols for shared libraries +........................ done</p>

<p>Breakpoint 1, main () at test.c:5
5         int i = 10;
(gdb) step
7         p = &i;
(gdb) print i
$1 = 10
(gdb) p &amp;i
$2 = (int <em>) 0x7fff5fbfef94
(gdb) print p
$4 = (int </em>) 0x7fff5fbfef94
(gdb) p *p
$5 = 10
```</p>

<p>then try to use x to examine memory:</p>

<p><code>
(gdb) x/1bt p
0x7fff5fbfef94: 00001010
(gdb) x/1bt &amp;i
0x7fff5fbfef94: 00001010
(gdb) x/1bt *&amp;p
0x7fff5fbfef94: 00001010
(gdb) x/1bt &amp;p
0x7fff5fbfef88: 10010100
</code></p>

<p>So, my suggestion is read for sure K&amp;R about pointers then open your editor, compile some code and then play with gdb till you will clear understand how and why it works. Good luck!</p>
]]></content>
  </entry>
  
</feed>
