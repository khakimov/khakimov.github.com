<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | nameless]]></title>
  <link href="http://khakimov.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2014-08-17T18:06:23-07:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Twitter Mass Unfollow with Ruby]]></title>
    <link href="http://khakimov.github.com/blog/2012/08/12/twitter-mass-unfollow-with-ruby/"/>
    <updated>2012-08-12T17:26:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/08/12/twitter-mass-unfollow-with-ruby</id>
    <content type="html"><![CDATA[<p>On Saturday morning decided to mass unfollow all of user from my list, because folowed ~800 and even with list it's a lot. So, ruby and couple lines of code solved this problem.</p>

<script src="https://gist.github.com/3307549.js?file=gistfile1.rb"></script>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[X-RateLimit-Limit API]]></title>
    <link href="http://khakimov.github.com/blog/2012/06/18/x-ratelimit-limit-api/"/>
    <updated>2012-06-18T14:38:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/06/18/x-ratelimit-limit-api</id>
    <content type="html"><![CDATA[<p>some api have a limit requests, like to 5000 per hour as github has:
○ curl -i https://api.github.com/users/whatever</p>

<p><code>
HTTP/1.1 200 OK
Status: 200 OK
X-RateLimit-Limit: 5000
X-RateLimit-Remaining: 4966
</code></p>

<p>or angel.co 1000 per hour requests:</p>

<p><code>
○ curl -i http://api.angel.co/
...
Server: nginx
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 978
</code></p>

<p>Never've seen this before :lame, but as tip - if you are building API and want to limit requests check this link <a href="http://www.ruby-forum.com/topic/201555">http://www.ruby-forum.com/topic/201555</a>, from flip side you can use it as a counter.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Puzzle Node #1]]></title>
    <link href="http://khakimov.github.com/blog/2012/06/04/puzzle-node-number-1/"/>
    <updated>2012-06-04T13:21:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/06/04/puzzle-node-number-1</id>
    <content type="html"><![CDATA[<p>First of all I'm not going to spoil here any solution, just my thoughts about solving this. In my case the main problem with puzzles is focus. You don't need to be awesome programmer to solve it, just need to understand what to solve and then just write few lines of code.</p>

<p><a href="http://puzzlenode.com/puzzles/1-international-trade">Puzzle</a> <strong>"International trade"</strong> has two files. The first is an XML file containing the conversion rates for exchanging one currency with another. The second is a CSV file containing sales data by transaction for an international business. Your goal is to parse all the transactions and return the grand total of all sales for a given item. Currently I stuck with <em>Some conversion rates are missing; you will need to derive them using the information provided.</em></p>

<p>It means if we have pair EUR/USD and EUR/AUD we have to derive USD/AUD.</p>

<p>EUR/USD 1.2494 -> USD/EUR 0.8003
EUR/AUD 1.2846 -> AUD/EUR 0.7785
USD/AUD 1.2846 / 1.2494 or 0.8003 * 1.2846 or 0.8003 / 0.7785 = 1.028</p>

<p>Ok, SAMPLE_RATES.xml has this curr</p>

<p>```xml
&lt;?xml version="1.0"?>
<rates>
  <rate></p>

<pre><code>&lt;from&gt;AUD&lt;/from&gt;
&lt;to&gt;CAD&lt;/to&gt;
&lt;conversion&gt;1.0079&lt;/conversion&gt;
</code></pre>

<p>  </rate>
  <rate></p>

<pre><code>&lt;from&gt;CAD&lt;/from&gt;
&lt;to&gt;USD&lt;/to&gt;
&lt;conversion&gt;1.0090&lt;/conversion&gt;
</code></pre>

<p>  </rate>
  <rate></p>

<pre><code>&lt;from&gt;USD&lt;/from&gt;
&lt;to&gt;CAD&lt;/to&gt;
&lt;conversion&gt;0.9911&lt;/conversion&gt;
</code></pre>

<p>  </rate>
</rates>
```</p>

<p>our program should convert and find USD/AUD. Let's do it on the papper and then code.</p>

<p>AUD/CAD 1.0079
CAD/USD 1.0090</p>

<p>USD/CAD 0.9911</p>

<p>USD/AUD ?      <br/>
USD/CAD 0.9911 / AUD/CAD    1.0079 = 0.9833</p>

<p>To find USD/AUD I should devided USD/CAD and AUD/CAD. So, in our case if we are looking for USD/AUD - USD/$CUR devided AUD/$CUR. If we don't have USD/$CUR we can convert $CUR/USD to USD/$CUR just devided 1/rate.</p>

<ol>
<li>Build hash with current rates.</li>
<li>Derive inverted pair. USD/CAD -> CAD/USD (deviding 1/currency)</li>
<li>Find the pair that need to find.</li>
</ol>


<p>few days later I've decided that is not good solution. Here is new refactored version:</p>

<ol>
<li>Build hash with current rates.</li>
<li>Derive with recursion. For example if we have AUD/CAD and CAD/USD we just derive AUD to CAD and then CAD to USD, so we will get AUD/USD.</li>
</ol>


<p>ps: yea, I've solved it. Going to try <a href="http://puzzlenode.com/puzzles/2-cheap-tourist-fast-tourist">next one</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My first gem]]></title>
    <link href="http://khakimov.github.com/blog/2012/05/24/my-first-gem/"/>
    <updated>2012-05-24T16:04:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/05/24/my-first-gem</id>
    <content type="html"><![CDATA[<p>Long time no post here, was a busy month. Learning a lot of stuff about algorithms as I said before and now I know how packers work (like zip, tar etc). Will be also good to complete of those algorithms on ruby, like binary tree search and tries, will see.</p>

<p>Btw, doing some stuff with rails now I've relised my first gem. It called <a href="https://github.com/khakimov/id_encoder">id_encoder</a> and this is pretty cool encoder which helps you generating consecutive, predictable URLs. Here is description:</p>

<blockquote><p>Ruby implementation for generating Tiny URL- and bit.ly-like URLs.</p>

<p>A bit-shuffling approach is used to avoid generating consecutive, predictable URLs. However, the algorithm is deterministic and will guarantee that no collisions will occur.</p>

<p>The URL alphabet is fully customizable and may contain any number of characters. By default, digits and lower-case letters are used, with some removed to avoid confusion between characters like o, O and 0. The default alphabet is shuffled and has a prime number of characters to further improve the results of the algorithm.</p>

<p>The block size specifies how many bits will be shuffled. The lower BLOCK_SIZE bits are reversed. Any bits higher than BLOCK_SIZE will remain as is. BLOCK_SIZE of 0 will leave all bits unaffected and the algorithm will simply be converting your integer to a different base.</p>

<p>The intended use is that incrementing, consecutive integers will be used as keys to generate the short URLs. For example, when creating a new URL, the unique integer ID assigned by a database could be used to generate the URL by using this module. Or a simple counter may be used. As long as the same integer is not used twice, the same short URL will not be generated twice.</p>

<p>The module supports both encoding and decoding of URLs. The min_length parameter allows you to pad the URL if you want it to be a specific length.</p></blockquote>

<p>In few words - you can use it with uniq integer of id record from database and convert to symbols:</p>

<p><code>
IdEncoder::UrlEncoder.encode_url(10) # =&gt; "csqsc"
IdEncoder::UrlEncoder.decode_url('csqsc') # =&gt; 10
</code></p>

<p>cool, isn't? Epicly awesome part was using "low" ruby like OR/AND, Bitwise &lt;&lt;. Looks like you coding asembler or some machine binary language. It's remind me childhod, that I was young and trees was so big I did some asembler code (mov ax, bx ... int 21h ...)</p>

<p>So, next big thing is going to be RSpect. I really want to start using tests and start projects from test and only then code. It looks cool when you know what to do with test, but now this is hard to switch from code to test first. Will update my gem with tests soon!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Back to school: Linked List with Ruby]]></title>
    <link href="http://khakimov.github.com/blog/2012/05/11/back-to-school-linked-list-with-ruby/"/>
    <updated>2012-05-11T13:27:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/05/11/back-to-school-linked-list-with-ruby</id>
    <content type="html"><![CDATA[<p>CS106B is awesome! Today was a lecture about <a href="/blog/2012/04/27/data-structure/">Linked List</a> as I've already mention about this Data structures.</p>

<p>Linked lists are among the simplest and most common data structures. They can be used to implement several other common abstract data types, including stacks, queues, associative arrays, and symbolic expressions, though it is not uncommon to implement the other data structures directly without using a list as the basis of implementation. <a href="http://en.wikipedia.org/wiki/Linked_list">wikipedia</a></p>

<p>With C++ we can represent a cell in the linked list as a structure, like</p>

<p>``` c++
struct Cell {</p>

<pre><code>string value; 
Cell* next; 
</code></pre>

<p>};
```</p>

<p>in Ruby we can also use <a href="http://www.ruby-doc.org/core-1.9.3/Struct.html">Struct</a> and code our LinkedList will be like this:</p>

<p>``` ruby</p>

<h1>create a struct with :value and :next</h1>

<p>Cell = Struct.new(:value, :next)</p>

<h1>create a head of our list</h1>

<p>list = Cell.new("head. hi", nil)</p>

<h1>method which create one more cell and return the struct</h1>

<p>def linked_list(value, cell)</p>

<pre><code>return Cell.new(value, cell)
</code></pre>

<p>end</p>

<h1>method which recursively print value until the asteroid...</h1>

<p>def recursive_print(list)</p>

<pre><code>p list.value
recursive_print(list.next) unless list.next == nil
</code></pre>

<p>end</p>

<h1>create Linked List</h1>

<h1>#<struct Cell value=10, ... next=#<struct Cell value=1, next=#<struct Cell value="head. hi", next=nil></h1>

<p>i = 0
10.times {</p>

<pre><code>i += 1
list = linked_list(i, list)
</code></pre>

<p>}</p>

<p>recursive_print(list) # print out recursively our list
```</p>

<p>Let's test Linked List and Arrays to insert value in the top.</p>

<p>``` ruby simple_bench.rb</p>

<h1>create a struct with :value and :next</h1>

<p>Cell = Struct.new(:value, :next)</p>

<h1>create a head of our list</h1>

<p>list = Cell.new("head. hi", nil)</p>

<h1>array</h1>

<p>a = []</p>

<h1>method which create one more cell and return the struct</h1>

<p>def linked_list(value, cell)</p>

<pre><code>return Cell.new(value, cell)
</code></pre>

<p>end</p>

<h1>simple benchmark timer. t1 - t2 = waiting time ;)</h1>

<p>def bench type
  t1 = Time.now
  yield
  t2 = Time.now
  p "#{type}'s took #{t2 - t1}s"
end</p>

<p>bench ("array") {
  100000.times { a.insert 0,10} # O(n)
}</p>

<p>bench ("linked list") {
  100000.times { list = linked_list(10, list) } # O(1)
}</p>

<h1>results</h1>

<p>#</p>

<h1>"array's took 2.661794s"</h1>

<h1>"linked list's took 0.050272s"</h1>

<p>```</p>

<p>I'm not sure this is good example of benchmarking, will check it later. What doest it all mean? If you want insert value in the head of array, array gets a new array and move everything over every time when you insert something.</p>

<p><strong>[1, 2, 3, 4, 5, 6]</strong> -> inserting <strong>10071983</strong> value -> <strong>[10071983, 1, 2, 3, 4, 5, 6]</strong>, so now inserting an element into a top of array can be very costly - O(n) because everytime move everything over.</p>

<p>with linked list you just create cell with element and pointer on next cell. <strong>[1, pointer->nil]</strong> and if we want to add new element, we just set pointer like <strong>[10071983, pointer->next]</strong> where pointer->next is reference to <strong>[1, nil]</strong>. Of course Arrays are cool, because you can do many other things faster than linked list (trade offs), but don't forget about Algorithmic Analysis where you can find what will be faster to use in your case.</p>
]]></content>
  </entry>
  
</feed>
