<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: crawl | curious and driven]]></title>
  <link href="http://khakimov.github.com/blog/categories/crawl/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2012-12-29T14:34:48-08:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EventMachine. Day 3]]></title>
    <link href="http://khakimov.github.com/blog/2012/04/23/eventmachine-day-3/"/>
    <updated>2012-04-23T12:41:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/04/23/eventmachine-day-3</id>
    <content type="html"><![CDATA[<p>Just bought large coffee from Coupa cafe and ready for the next fight. Today I read few article and checked few github repositories with eventmachine examples.</p>

<p><a href="http://blog.nominet.org.uk/tech/2007/10/12/dnsruby-and-eventmachine/">Dnsruby and EventMachine</a></p>

<p>So, now I'm reading about <a href="http://eventmachine.rubyforge.org/docs/DEFERRABLES.html">Deferrables</a> and the only one thing I'm gonna share with you - <em>You may need to read the following material through more than once before you get the idea.</em> =)</p>

<blockquote><p>The Deferrable pattern allows you to specify any number of Ruby code blocks (callbacks or errbacks) that will be executed at some future time when the status of the Deferrable object changes. How might that be useful? Well, imagine that youâ€™re implementing an HTTP server, but you need to make a call to some other server in order to fulfill a client request.</p></blockquote>

<p>When you'll read it you'll realize that we've already used EM::Deferrable. For example when we are using EM::Protocols::HttpClient#request it returns a Deferrable object.</p>

<p>``` ruby
df = EM::Protocols::HttpClient.request( :host=>"www.example.com", :request=>"/index.html" )</p>

<p>df.callback {|response|
  puts "Succeeded: #{response[:content]}"
  EM.stop
}</p>

<p>df.errback {|response|
  puts "ERROR: #{response[:status]}"
  EM.stop
}
```</p>

<p>It works, but still speed is not good as I'm looking for. My idea is creating a pool with 200 connections in the same time and recursively adding new connection each time when old connection finished. Some specs here:</p>

<ul>
<li>200 connections in the same time always</li>
<li>connection timeout = 3 seconds</li>
<li>connection innactive = 5 seconds</li>
</ul>


<p><img src="http://pix.am/HTuTl.png" alt="" /></p>

<p>Because I don't have internet connection in the library I'm going build server with random timeout response between 1-3 seconds. Let's do it with eventmachine ;)</p>

<p>``` ruby server.rb
require 'eventmachine'</p>

<p>class Server &lt; EventMachine::Connection</p>

<p>  def receive_data(data)</p>

<pre><code>p EM.connection_count
sleep(rand()*2)
send_data "200"
close_connection_after_writing
</code></pre>

<p>  end</p>

<p>end</p>

<p>EM.run do
  EM::start_server "0.0.0.0", 8000, Server
end
```</p>

<p>``` ruby client.rb
require 'eventmachine'</p>

<p>class Client &lt; EM::Connection</p>

<p>  def initialize num, started_at</p>

<pre><code>@num = num
@started_at = started_at
</code></pre>

<p>  end</p>

<p>  def post_init</p>

<pre><code>  send_data "hi\r\n"
</code></pre>

<p>  end</p>

<p>  def receive_data data</p>

<pre><code>p "#{@num} - #{Time.now - @started_at}- #{data}"
close_connection
</code></pre>

<p>  end</p>

<p>end</p>

<p>EM.run do
  EM::Iterator.new(0..100, 5).each { |num, iter|</p>

<pre><code>EM.connect "127.0.0.1", 8000, Client, num, Time.now()
iter.next
</code></pre>

<p>  }
end
```</p>

<p>2 hours break and here I am, though a little bit more and here is new version of previous awful code:</p>

<p>``` ruby server.rb
require 'eventmachine'</p>

<p>EM.run do</p>

<pre><code>EM::start_server "0.0.0.0", 8000 do |serv|
  def serv.receive_data data
    EM.add_timer(rand()*4) { 
      send_data "200" 
      close_connection_after_writing
    }
    puts EM.connection_count
  end
end
</code></pre>

<p>end
```</p>

<p>``` ruby client.rb
require 'eventmachine'</p>

<p>class Client &lt; EM::Connection</p>

<p>  def initialize num, started_at</p>

<pre><code>@num = num
@started_at = started_at
</code></pre>

<p>  end</p>

<p>  def post_init</p>

<pre><code>  send_data "ping"
</code></pre>

<p>  end</p>

<p>  def receive_data data</p>

<pre><code>p "#{@num} - #{Time.now - @started_at}- #{data}"
close_connection
</code></pre>

<p>  end</p>

<p>end</p>

<p>EM.run do
  EM::Iterator.new(0..100, 5).each { |num, iter|</p>

<pre><code>EM.connect "127.0.0.1", 8000, Client, num, Time.now()
iter.next
</code></pre>

<p>  }
end
```</p>

<p>because in prev version of server.rb I've used sleep, that was a problem for reactor (EM) and it blocked the process. So, now results looks better:</p>

<p>```
ruby client.rb</p>

<p>...
"31 - 3.348352- 200"
"62 - 3.571507- 200"
"91 - 3.582121- 200"
"29 - 3.602537- 200"
"92 - 3.59524- 200"
"1 - 3.671826- 200"
"35 - 3.686029- 200"
"80 - 3.776847- 200"
"63 - 3.800448- 200"
"43 - 3.856598- 200"
"30 - 3.906939- 200"
```</p>

<p>BUT if you write EM::Iterator.new(0..10000, 50).each it will be frozen for 10-20 seconds and only then you will get a result. Day 3 and again fail. But tomorrow is going be more interesting, because the truth is out there...</p>

<p>To read:</p>

<p><a href="http://nutrun.com/weblog/2008/05/04/distributed-programming-with-jabber-and-eventmachine.html">Distributed programming with Jabber and EventMachine</a>
<a href="http://blog.nominet.org.uk/tech/2007/10/12/dnsruby-and-eventmachine/">Dnsruby and EventMachine</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EventMachine and web crawler]]></title>
    <link href="http://khakimov.github.com/blog/2012/04/21/eventmachine-and-web-crawler/"/>
    <updated>2012-04-21T14:47:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/04/21/eventmachine-and-web-crawler</id>
    <content type="html"><![CDATA[<p>When I came back at home yesterday and tested the code on real data I realized that wasn't work well. 1000 urls was ok, but 1_000_000 wasn't, EM didn't callback anything.</p>

<p>``` ruby
require 'eventmachine'</p>

<p>urls = []</p>

<p>File.open("1.csv", 'r') do |f|
  while(line = f.gets)</p>

<pre><code>urls &lt;&lt; line.split(",")[1].strip
#urls &lt;&lt; "http://127.0.0.1"
</code></pre>

<p>  end
end
p urls.size</p>

<p>module DumbHttpClient
   def post_init</p>

<pre><code> send_data "GET / HTTP/1.1\r\nHost: _\r\n\r\n"
 @data = ""
 @parsed = false
</code></pre>

<p>   end</p>

<p>   def receive_data data</p>

<pre><code> @data &lt;&lt; data
 if !@parsed and @data =~ /[\n][\r]*[\n]/m
   @parsed = true
   p data
   close_connection
 end
</code></pre>

<p>   end</p>

<p>   def unbind</p>

<pre><code> puts "A connection has terminated"
</code></pre>

<p>   end
 end</p>

<p> EventMachine::run {
   urls.each do |url|</p>

<pre><code> begin
   EventMachine::connect url, 80, DumbHttpClient
 rescue EventMachine::ConnectionError
   p "Something wrong with #{url}"
 end
 p EM::connection_count()
</code></pre>

<p>   end
 }</p>

<p> puts "The event loop has ended"
```</p>

<p>This simple example which just send/receive data from web. It works well only if you try to grab ~1000 websites. Before gets result its going through <em>.each</em> and only after finish this loop starts sending data and receive_data. Version with BATCH_SIZE that I did yesterday pretend to create queue and that's why it works with 1_000_000 urls, but after first hundred requests speed goes down.</p>

<p>Then I've read about <a href="http://rdoc.info/github/eventmachine/eventmachine/master/EventMachine/Iterator">EM::Iterator</a> and did this example:</p>

<p>``` ruby
require 'eventmachine'
require 'em-http'
urls = []
File.open("1.csv", 'r') do |f|
  while(line = f.gets)</p>

<pre><code>urls &lt;&lt; "http://" + line.split(",")[1].strip
</code></pre>

<p>  end
end
BATCH_SIZE = 100</p>

<p>EM.kqueue = true
successes = 0
failures = 0
EventMachine.run {
  pending = 0
  EM.add_periodic_timer(1) do</p>

<pre><code>batch, urls = urls[0..(BATCH_SIZE-1)], (urls[BATCH_SIZE..-1] || []) 
EM::Iterator.new(batch, 100).each do |url,iter| 
  http = EM::HttpRequest.new(url, :connect_timeout =&gt; 3, :inactivity_timeout =&gt; 5).get 

  http.callback {
    puts "#{url} - #{http.response_header['SERVER']}"
    successes += 1
    pending -= 1
    iter.next
    EM.stop if pending &lt; 1 &amp;&amp; urls.empty?
  }

  http.errback {
    puts "#{url}\n - #{http.error}"
    failures += 1
    pending -= 1
    iter.next
    EM.stop if pending &lt; 1 &amp;&amp; urls.empty?
  }
  pending += 1
  iter.next
end
puts "#{pending} pending. #{successes} successful, #{failures} failures"
p EM::connection_count()
</code></pre>

<p>  end
}
```</p>

<p>Works, but speed not as I expected. Network used only 200kb/s and 1mbit once at the pick. So, that means parallels works not as we want, we want to use network as much as possible.</p>

<p>Then I've read about <a href="https://github.com/igrigorik/em-synchrony">em-synchrony</a> and did this example of crawler (ruby 1.9.3 and em-synchrony):</p>

<p>``` ruby
require 'em-synchrony'
require 'em-synchrony/em-http'</p>

<p>urls = []</p>

<p>File.open("10k.csv", 'r') do |f|
  while(line = f.gets)</p>

<pre><code>urls &lt;&lt; "http://" + line.split(",")[1].strip
</code></pre>

<p>  end
end
p urls.size
t1 = Time.now
successes = 0
failures = 0
EM.synchrony do
  concurrency = 200
  pending = 0
  # iterator will execute async blocks until completion, .each, .inject also work!
  results = EM::Synchrony::Iterator.new(urls, concurrency).map do |url, iter|</p>

<pre><code>  # fire async requests, on completion advance the iterator
  http = EventMachine::HttpRequest.new(url).aget
  http.callback { 
    iter.return(http) 
    successes += 1
    pending -= 1
    puts "#{successes} successful, #{failures} failures, connection #{EM::connection_count()}"
    }
  http.errback { 
    iter.return(http) 
    failures += 1
    pending -= 1
    }
</code></pre>

<p>  end</p>

<p>  p results # all completed requests
  EventMachine.stop
end
t2 = Time.now</p>

<p>puts "#{successes} successful, #{failures} failures in #{t2 - t1} s"
```</p>

<p>Since I've done a lot of examples I've learned a good lesson - never block the main EM.run {}:</p>

<ul>
<li>no sleep(1)</li>
<li>no long loops like I did 10_000.each</li>
<li>no blocking I/O</li>
</ul>


<p>concurrency = 1000</p>

<p>935 successful, 65 failures in 186.044609 s</p>

<p>concurrency = 50</p>

<p>957 successful, 43 failures in 67.982429 s</p>

<p>concurrency = 300</p>

<p>956 successful, 44 failures in 26.822961 s</p>

<p>In the next post I'm going to try EM::Deferrable and will see how it will work. Still don't have good solution, so, keep digging. I just wanna get the shit out of my internet connection, like using bandwidth as can as possible ;)</p>
]]></content>
  </entry>
  
</feed>
