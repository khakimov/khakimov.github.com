<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: websocket | curious and driven]]></title>
  <link href="http://khakimov.github.com/blog/categories/websocket/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2013-10-09T10:20:07-07:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EventMachine and WebSockets]]></title>
    <link href="http://khakimov.github.com/blog/2012/04/30/eventmachine-and-websockets/"/>
    <updated>2012-04-30T18:46:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/04/30/eventmachine-and-websockets</id>
    <content type="html"><![CDATA[<p>Few days couldn't use mt keyboard because fell of my bike and hurt my arms. Still using only one hand and that's enough to start doing some epic code ;) Today I'm going to start exploring world of websockets when you can send data from server to client's browser. Two things required - eventmachine as usual and em-websocket (<em>gem install em-websocket</em>)</p>

<p>The simplest echo server/client:</p>

<p>``` ruby
require 'eventmachine'
require 'em-websocket'</p>

<p>EM.run do
  puts "Server started on 127.0.0.1:4000 (open index.html in your browser)"
  EM::WebSocket.start(:host => '127.0.0.1', :port => 4000) do |websocket|</p>

<pre><code>websocket.onopen { puts "Client connected" }
websocket.onmessage do |msg|
  p msg
  websocket.send(msg)
end
</code></pre>

<p>  end
end
```</p>

<p>``` html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"></p>

<p><html lang="en">
<head></p>

<pre><code>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;index&lt;/title&gt;
&lt;script src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js'&gt;&lt;/script&gt;
&lt;script&gt;
  var ws;

  $(document).ready(function()
  {
    if (!("WebSocket" in window))
    {
      alert("Sorry, WebSockets unavailable.");
      return;
    }

    ws = new WebSocket("ws://127.0.0.1:4000/");

    ws.onopen = function() {
        console.log("connected...");
        ws.send("hello server");
        ws.send("hello again");  
    };
    ws.onmessage = function(evt)
    {
        console.log(evt);
        $('#echo').append(evt.data +"&lt;br&gt;");
    };

    ws.onclose = function()
    {
      console.log("socket closed");
    };
});
&lt;/script&gt;
</code></pre>

<p></head></p>

<pre><code>&lt;body&gt;
    meh
    &lt;div id="echo"&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<h2>websocket client side</h2>

<ul>
<li><strong>ws = new WebSocket("ws://127.0.0.1:4000/");</strong> create WebSocket object</li>
<li><strong>onopen</strong> - call it when a socket has opened</li>
<li><strong>onmessage</strong> - call it when a message has been received</li>
<li><strong>onclose</strong> - when a socket has been closed</li>
</ul>


<h2>websocket server side</h2>

<ul>
<li><strong>EM::WebSocket.start(:host => '127.0.0.1', :port => 4000) do |websocket|</strong> open and listen requests on port 4000</li>
<li><strong>onopen</strong> - call it when a socket has opened</li>
<li><strong>onmessage</strong> - call it when a message has been received</li>
<li><strong>onclose</strong> - when a socket has been closed</li>
</ul>


<p>Let's play a little bit with websocket and our last project that scans websites and gets <strong>header</strong> (I'm really n00b with frontend stuff, so, don't judge me)</p>

<p>``` html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"></p>

<p><html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>index</title>
  <meta name="author" content="Ruslan Khakimov">
  <script src='http://127.0.0.1:3000/jquery-1.7.2.js'></script></p>

<pre><code>&lt;script&gt;
  var ws;

  $(document).ready(function()
  {
    if (!("WebSocket" in window))
    {
      alert("Sorry, WebSockets unavailable.");
      return;
    }

    ws = new WebSocket("ws://127.0.0.1:8080/");

    ws.onopen = function() {
        console.log("connected...");
    };

    ws.onmessage = function(evt)
    {
        data = JSON.parse(evt.data);
        nginx = data.nginx;
        apache = data.apache;
        ms = data.ms; 
        total = nginx + apache + ms;

        render_star('nginx', nginx/total * 100);
        render_star('apache', apache/total * 100);
        render_star('ms', ms/total * 100);

    };

    ws.onclose = function()
    {
      console.log("socket closed");
    };

    function render_star(name, num){
      $('#' + name).html('');
      for(var i =0; i&lt; num; i++) {
        $('#'+ name).append('*');
      }

    };

});
&lt;/script&gt;
</code></pre>

<p></head>
<body></p>

<p>  <div id="test"></p>

<pre><code>nginx: &lt;div id="nginx"&gt;&lt;/div&gt;
apache: &lt;div id="apache"&gt;&lt;/div&gt;
ms: &lt;div id="ms"&gt;&lt;/div&gt;
</code></pre>

<p>  </div></p>

<p></body>
</html>
```</p>

<p>and server:
``` ruby server.rb
require 'eventmachine'
require "em-websocket"
require "json"</p>

<p>module EventMachine
  module DNS</p>

<pre><code>class Request
  def initialize(socket, hostname)
    @socket = socket
    @hostname = hostname
    @tries = 0
    @last_send = Time.at(0)
    @retry_interval = 3
    @max_tries = 5

    if addrs = Resolver.hosts[hostname]
      info = {"domain"=&gt; @hostname, "ips" =&gt; addrs}
      succeed info
    else
      EM.next_tick { tick }
    end
  end

  def receive_answer(msg)
    addrs = []
    msg.each_answer do |name,ttl,data|
      if data.kind_of?(Resolv::DNS::Resource::IN::A) ||
          data.kind_of?(Resolv::DNS::Resource::IN::AAAA)
        addrs &lt;&lt; data.address.to_s
      end
    end

    if addrs.empty?
      fail "rcode=#{msg.rcode}, #{@hostname}"
    else
      info = {"domain"=&gt; @hostname, "ips" =&gt; addrs}
      succeed info
    end
  end
end
</code></pre>

<p>  end
end</p>

<p>urls = []</p>

<p>File.open("1.csv", 'r') do |f|
  while(line = f.gets)</p>

<pre><code>urls &lt;&lt; line.split(",")[1].strip
</code></pre>

<p>  end
end</p>

<p>class Client &lt; EM::Connection
  @@webserver_stats = {"nginx" => 0, "apache" => 0, "ms" => 0}</p>

<p>  def initialize domain, channel</p>

<pre><code>@domain = domain
comm_inactivity_timeout = 3
pending_connect_timeout = 5
@channel = channel
</code></pre>

<p>  end</p>

<p>  def post_init</p>

<pre><code>send_data "GET / HTTP/1.1\r\nHost: #{@domain}\r\n\r\n"
</code></pre>

<p>  end</p>

<p>  # Parse answer from webserver and count stats
  def receive_data data</p>

<pre><code>data =~ /Server: ([^\r\n]*)/
webserver = $1
case webserver
when /nginx/      then  @@webserver_stats.merge({"nginx" =&gt; @@webserver_stats['nginx'] += 1})
when /Apache/     then  @@webserver_stats.merge({"apache" =&gt; @@webserver_stats['apache'] += 1})
when /Microsoft/  then  @@webserver_stats.merge({"ms" =&gt; @@webserver_stats['ms'] += 1})
end
p webserver
@channel.push @@webserver_stats

close_connection
</code></pre>

<p>  end</p>

<p>end</p>

<p>successes = 0
failures = 0
total_connection = 0
t1 = Time.now
urls_size = urls.size</p>

<p>EM.run do</p>

<p>@channel = EM::Channel.new</p>

<p>  connect = proc {</p>

<pre><code>if EM::connection_count() &lt; 300
  url = urls.pop
  dns = EM::DNS::Resolver.resolve url

  dns.callback {|data|
    successes += 1
    EM.connect data["ips"][0], 80, Client, data["domain"], @channel unless data["ips"][0].nil?
  }

  dns.errback { |data| failures += 1 }

  total_connection += 1
end

if total_connection &lt; urls_size 
  EM.add_timer(1) { EM.next_tick(&amp;connect) }  #originaly here should be something like 0.002, but this is test
else
  EM.add_timer(5) {EM.stop}   # 5 seconds timer to lets finish slow connections
end
</code></pre>

<p>  }</p>

<p>  EM.next_tick(&amp;connect)</p>

<p>  # print stats with progress every 3 seconds
  stats = proc {</p>

<pre><code>  p "current connection: #{EM::connection_count()}, total: #{total_connection}, #{successes}\
    successful, #{failures} failures, #{ (successes / (Time.now - t1)).to_i} domains/sec"
  EM.add_timer 3, &amp;stats
</code></pre>

<p>  }
  EM.add_timer 3, &amp;stats</p>

<p>  # starts websocket server
  EM::WebSocket.start(:host => "127.0.0.1", :port => 8080, :debug => false) do |ws|</p>

<p>  ws.onopen {</p>

<pre><code>sid = @channel.subscribe { |msg| ws.send msg.to_json }

ws.onclose {
  @channel.unsubscribe(sid)
}
</code></pre>

<p>  }
  end
end</p>

<p>t2 = Time.now
p "Total #{total_connection}, #{successes} successful, #{failures} failures in #{t2 - t1}s"
```
...few days of repairing after bike crash...</p>

<p>Thats how simple using websockets is, and combined with eventmachine, they can be pretty awesome together. This is the end of my journey with EM for this time and I'm going to improve some skills with Rails. Let me know on email ruslan@&lt;%= current_domain_name %> if you have any question about eventmachine.</p>
]]></content>
  </entry>
  
</feed>
