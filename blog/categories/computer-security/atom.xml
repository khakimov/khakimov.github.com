<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: computer security | Doing things]]></title>
  <link href="http://khakimov.github.com/blog/categories/computer-security/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2012-12-09T23:18:29-08:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Bypassing DEP/ASLR protections]]></title>
    <link href="http://khakimov.github.com/blog/2012/12/09/bypassing-dep-slash-aslr-protections/"/>
    <updated>2012-12-09T21:13:00-08:00</updated>
    <id>http://khakimov.github.com/blog/2012/12/09/bypassing-dep-slash-aslr-protections</id>
    <content type="html"><![CDATA[<p>Today we are going to learn about data execution prevention (DEP) and address space layout randomization (ASLR). Last Sunday I read about <a href="http://khakimov.com/blog/2012/12/02/return-into-libc-without-function-calls/">return-into-libc</a> and one week before was post about <a href="http://khakimov.com/blog/2012/11/20/buffer-overflow/">buffer overflow</a> as-is. Both methods reqired to know the address of attacker shellcode and/or standard kernel library (we found out the address of system() function in the memory to use it in <strong>return-into-libc</strong> with this code int main() { system();}). Modern systems decided to implement something what will make stack addresses and addressess of library routines unpredictable and different from machine to machine (no more universal exploits =) kidding).</p>

<p>Author <a href="https://twitter.com/justdionysus">Dionysus Blazakis</a> holds BS from University of Maryland and doing interesting things, I saw his presentation "The Apple Sandbox" and then found this paper, great job Dionysus. I inspired by his example and it motivates me to keep digging in research field. Dion, if you'll ever read this I just want to say thank you! Lets get back to his paper and read what this smart fellow prepared for us.</p>

<p><a title="View Blazakis on Scribd" href="http://www.scribd.com/doc/116197211/Blazakis" style="margin: 12px auto 6px auto; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none; display: block; text-decoration: underline;">Blazakis</a><iframe class="scribd_iframe_embed" src="http://www.scribd.com/embeds/116197211/content?start_page=1&view_mode=scroll&access_key=key-1dr5xy06ojvmp97eq1hg" data-auto-height="false" data-aspect-ratio="0.772727272727273" scrolling="no" id="doc_39852" width="100%" height="600" frameborder="0"></iframe></p>

<p>DEP and ASLR are very real problem in the side of an exploit developer. DEP makes locating shellcode difficult, ASLR further complicates an attack by obfuscating the base address of the loaded data. Adobe Flash Player is used as an example, Dion also referenced to JIT spraying (Just-In-Time).</p>

<p><code>
A Just-in-time compiler (JIT), by definition, produces machine
code as its output. Since it produces executable data, a JIT
compiler is one of the few types of programs that **cannot** be
run in a **no-executable-data environment**. Therefore, JIT
compilers are normally exempt from data execution prevention. A
JIT spray compiles code that then proceeds to spray the memory
with enough instances of exploit code to overwhelm the address
space randomization and execute the exploit itself.
</code></p>

<p>JIT spraying is very simular to heap spraying, in simple terms attacker stuff heap with multiple copies of attack code (payload) and that increases the chances of successful exploitation.</p>

<p>JIT Spray Exploit Demo</p>

<iframe width="640" height="480" src="http://www.youtube.com/embed/HJuBpciJ3Ao?rel=0" frameborder="0" allowfullscreen></iframe>


<p>So, why do you need this? If you found the overflow in the modern browsers you will not able to use it easily, because of randomization, the address space is randomized and you don't know where to point EIP and even if you have data in the heap DEP wont allow you to execute it. But you can use Just-In-Time compiler which will allocate writable memory for you and write executable code into it. For more detail please read the paper above. Enjoy!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Return-into-libc without Function Calls]]></title>
    <link href="http://khakimov.github.com/blog/2012/12/02/return-into-libc-without-function-calls/"/>
    <updated>2012-12-02T14:12:00-08:00</updated>
    <id>http://khakimov.github.com/blog/2012/12/02/return-into-libc-without-function-calls</id>
    <content type="html"><![CDATA[<p>Since OpenBSD has a nonexecutable stack by default and you can also patch your Linux kernel and make nonexecutable stack through PaX, AMD and Intel recently added to their processors a per-page execute disable bit to ease WOX implementation and even Microsoft implement WOX (no location in memory into which the attacker can inject code to execute, or just imagine no memory location in a process image is marked both writable - W and executable - X) all it means you can not execute your shellcode on the stack.</p>

<p>Today I read about technique is known as <strong>return into libc</strong> by <a href="http://cseweb.ucsd.edu/~hovav/">Hovav Shacham</a> (btw, his Ph.D. advisor was professor of Computer Science and Electrial Engineering at Stanford <a href="http://crypto.stanford.edu/~dabo/">Dan Boneh</a>. I took his CS155 class, he is really good in his field).</p>

<p>What is this about? If we can't write in stack what should we do? We can't inject code, so, we will use code that already exists in the proccess image we are attacking. <strong>Libc</strong> is the usual target that contains various basic functions, such as printf() and exit(). These functions are share, so any program that uses the printf() function directs execution into the appropriate location in libc. And attacker with his explout can do the same thing and direct a program's execution into a certain function in libc. But in principle any available code, either from the program's text segment of from a library it links to, could be used instead libc.</p>

<p>Enjoy!</p>

<p><a title="View Geometry (1) on Scribd" href="http://www.scribd.com/doc/115228599/Geometry-1" style="margin: 12px auto 6px auto; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none; display: block; text-decoration: underline;">Geometry (1)</a><iframe class="scribd_iframe_embed" src="http://www.scribd.com/embeds/115228599/content?start_page=1&view_mode=scroll&access_key=key-1qjla86da9zi8xelaiqr" data-auto-height="false" data-aspect-ratio="0.772727272727273" scrolling="no" id="doc_22341" width="100%" height="600" frameborder="0"></iframe></p>

<p>I played a litle bit with <strong>return into libc</strong> and the main idea was to force the program to spawn a shell without executing anything on the stack, by returning int the libc function system().</p>

<p><code>c sys.c
int main(int argc, char *argv[])
{
   char buffer[5];
   strcpy(buffer, argv[1]);
   return 0;
}
</code></p>

<p><code>c tmp.c
int main()
{ system(); }
</code></p>

<p>```
rus@rus-desktop:/tmp $ gcc -o t tmp.c
rus@rus-desktop:/tmp $ gdb -q ./t
(gdb) break main
Breakpoint 1 at 0x804837a
(gdb) run
Starting program: /tmp/t</p>

<p>Breakpoint 1, 0x0804837a in main ()
(gdb) print system
$1 = {<text variable, no debug info>} 0xb7ed0d80 <system>
(gdb) quit
```</p>

<p>here we got address of function <strong>system()</strong> and it is located at <strong>0xb7ed0d80</strong>.</p>

<p><code>
rus@rus-desktop:/tmp $ ./a.out $(perl -e 'print "AAAA"x7 . "\x80\x0d\xed\xb7"')
sh: ????????: command not found
Segmentation fault
</code>
7 words of data are used for spacin in the exploit and then we call system() as you can see. In this example I don't pass any arguments, but it's should be of course "/bin/sh". That's my Sunday and happy hacking hours!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Buffer Overflow]]></title>
    <link href="http://khakimov.github.com/blog/2012/11/20/buffer-overflow/"/>
    <updated>2012-11-20T23:17:00-08:00</updated>
    <id>http://khakimov.github.com/blog/2012/11/20/buffer-overflow</id>
    <content type="html"><![CDATA[<p>I'm very interesting in research paper and want to know better what computer security research is like. I found Vitaly Shmatikov and his course about great papers in Computer Security and decided to try each weekend read and write about one paper.</p>

<p>Vitaly Shmatikov is one of most interesting person for me in computer security and privacy. He got his PhD at Stanford and his thesis was "<a href="https://www.cs.utexas.edu/~shmat/shmat_tcs.pdf">Finite-State Analysis of Security Protocols</a>", also his prof at Stanford was John C. Mitchell.</p>

<p>So, today I want to start with Buffer Overflow and here is paper 1999 by Crispin Cowan, Perry Wagle, Calton Pu,Steve Beattie, and Jonathan Walpole.</p>

<p><a title="View Overflow on Scribd" href="http://www.scribd.com/doc/113583111/Overflow" style="margin: 12px auto 6px auto; font-family: Helvetica,Arial,Sans-serif; font-style: normal; font-variant: normal; font-weight: normal; font-size: 14px; line-height: normal; font-size-adjust: none; font-stretch: normal; -x-system-font: none; display: block; text-decoration: underline;">Overflow</a><iframe class="scribd_iframe_embed" src="http://www.scribd.com/embeds/113583111/content?start_page=1&view_mode=scroll&access_key=key-39aierbs22vhrn0azpl" data-auto-height="true" data-aspect-ratio="0.772727272727273" scrolling="no" id="doc_1657" width="100%" height="600" frameborder="0"></iframe></p>

<p>Btw, in this paper they metioned about Morris Worm and early versions of using buffer overflow and I found the peace of Morris Worm's overflow:</p>

<p><code>
; VAX binary code fragment from the Morris Internet Worm.
; Downloaded to the fingerd serving process via the gets() hole.
; Performs execve(“/bin/sh”,0,0)
pushl $0068732f   ; last half of name: "/sh\0"
pushl $6e69622f   ; first half of name: "/bin"
mov   sp,r10            ; pointer to the string
pushl $0          ; 3rd parameter: environment = null
pushl $0          ; 2nd parameter: args = null
pushl r10         ; 1st parameter: pointer to the executable name
pushl $3          ; 3 parameters on the stack
movl  sp,ap       ; ArgumentPointer points to arguments
chmk  $3b         ; SoftwareException 0x3B = EXECVE call
</code></p>

<p>It used a buffer overflow against the fingerd daemon. Other worms also often use buffer overflow to compromise the machine. CodeRed used overflow in MS-IIS server, SQL Slammer - overflow in MSSQL server, Sasser overflow in Windows LSASS, Conficker used overflow in Windows RPC and famous Stuxnet used several 0day overflows and same Windows RPC as Conficker. Looks like Buffer Overflow is the basis of many software vulnerabilities and can be maliciously exploited.</p>

<p>In computer security and programming, a buffer overflow, or buffer overrun, is an anomaly where a program, while writing data to a buffer, overruns the buffer's boundary and overwrites adjacent memory. <strong>Buffer</strong> is a data storage area inside computer memory (stack or heap).</p>

<p>Suppose we have Webserver contain this function</p>

<p>```c
void f(char *s) {</p>

<pre><code>  char buf[100];    // allocate 100 bytes on stack 
  strcpy(buf, s);   // copy argument into local buffer
</code></pre>

<p>}
```
<strong>strcpy</strong> does not check whether the string at *s contains fewer than 126 characters and if a string longer than 126 bytes is copied into buffer, it will overwrite adjacent stack locations.</p>

<p><img src="http://pix.am/ou9H.png" alt="" />
<img src="http://pix.am/HSH8.png" alt="" /></p>

<p>We overflow the return address and set address of attack code (the value in the RET position must point to the beginning of attack assembly code in the buffer, otherwise application will crash with segmentation violation).</p>

<p>Other exampe from <strong>Hacking</strong> book</p>

<p>```c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>int main(int argc, char **argv)
{
   int value = 5;
   char buffer_one[8], buffer_two[8];</p>

<p>   strcpy(buffer_one, "one");
   strcpy(buffer_two, "two");</p>

<p>   printf("[BEFORE] buffer_two is at %p contain \"%s\"", buffer_two, buffer_two);
   printf("[BEFORE] buffer_one is at %p contain \"%s\"", buffer_one, buffer_one);
   printf("[BEFORE] value is at %p and is %d (0x%08x)\n", &amp;value, value, value);</p>

<p>   printf("\n[STRCPY] copying %d bytes into buffer_two\n\n", (int) strlen(argv[1]));
   strcpy(buffer_two, argv[1]);</p>

<p>   printf("[AFTER] buffer_two is at %p and contains \'%s\'\n", buffer_two, buffer_two);
   printf("[AFTER] buffer_one is at %p and contains \'%s\'\n", buffer_one, buffer_one);
   printf("[AFTER] value is at %p and is %d (0x%08x)\n", &amp;value, value, value);</p>

<p>   return 0;
}
```</p>

<p><code>
overflow@hacking:~/booksrc $ gcc -o overflow_example overflow_example.c
overflow@hacking:~/booksrc $ ./overflow_example 1234567890
[BEFORE] buffer_two is at 0xbffff7f0 and contains 'two'
[BEFORE] buffer_one is at 0xbffff7f8 and contains 'one'
[BEFORE] value is at 0xbffff804 and is 5 (0x00000005)
[STRCPY] copying 10 bytes into buffer_two
[AFTER] buffer_two is at 0xbffff7f0 and contains '1234567890'
[AFTER] buffer_one is at 0xbffff7f8 and contains '90'
[AFTER] value is at 0xbffff804 and is 5 (0x00000005)
overflow@hacking:~/booksrc $
</code></p>

<p>Probably you will try to check this code on your computer (macos in my case), but <a href="https://en.wikipedia.org/wiki/Buffer_overflow_protection">buffer overflow protection</a> was included in release GCC 4.1 and you have to use <strong>-fno-stack-protector</strong> to compile your code. (hmm, i'm still getting error Program received signal SIGABRT, Aborted. which kills the proccess, couple clicks with google told me to recompile gcc. Seems now it's not easy to write bogus code =)). In this case I have virtual machine with 32-bit pretty old Ubuntu.</p>

<p>```c t.c</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;string.h></h1>

<p>void Q(char *arg) {</p>

<pre><code>char c[10];
strcpy(c, arg);
</code></pre>

<p>}</p>

<p>int main (int argc, char **argv) {</p>

<pre><code>  Q(argv[1]);
</code></pre>

<p>}
```</p>

<p>The return address in a stack frame can be located by undestanding how the stack frame is created. This process begins in the main() function even before the function call.</p>

<p>Couple things you have to know about the stack. The stack is used to pass prcedure arguments, <strong>to store return information</strong>, to save registers for later restoration and for local storage. The portion of the stack allocated for a single procedure call is called a <strong>stack frame</strong>. $EBP register serving as the <strong>frame pointer</strong> and register $ESP serving as the <strong>stack pointer</strong>.</p>

<p>The main idea is when main() calls Q() the <strong>return</strong> address within main() where the program should resume execution when it returns from Q. If somebody can overwrite return address it can jump or/and execute other code.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/4/4f/Stack_Overflow_2.png" alt="" /></p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/9/93/Stack_Overflow_3.png" alt="" /></p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Stack_Overflow_4.png" alt="" /></p>

<p>More details you can find in the paper above. If you are interesting in roots of the problem and how actually stack/heap works, I highly recommend to read the book <a href="http://www.amazon.com/Computer-Systems-A-Programmers-Perspective/dp/013034074X">Computer System: A Programmer's Perspective by Bryant and O'Hallaron</a>.</p>

<p>The first step is always the hardest. Will see how long I hold out.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Computer and Network Security specializations]]></title>
    <link href="http://khakimov.github.com/blog/2012/11/17/computer-and-network-security-specializations/"/>
    <updated>2012-11-17T10:41:00-08:00</updated>
    <id>http://khakimov.github.com/blog/2012/11/17/computer-and-network-security-specializations</id>
    <content type="html"><![CDATA[<p>a. Each of the following: CS 140, 144, 155, 244, 255</p>

<ul>
<li>CS 140: Operating Systems</li>
<li>CS 144: Introduction to Computer Networking (*)</li>
<li>CS 155: Computer and Network Security (*)</li>
<li>CS 244: Advanced Topics in Networking</li>
<li>CS 255: Introduction to Cryptography</li>
</ul>


<p>b. At least three of the following: CS 142, 240, 241, 244B, 244C, 259, 261, 340, 344, 355, 365</p>

<ul>
<li>CS 142: Web Applications (*)</li>
<li>CS 240: Advanced Topics in Operating Systems</li>
<li>CS 241: Secure Web Programming</li>
<li>CS 244B: Distributed Systems</li>
<li>CS 244C: Distributed System Projects</li>
<li>CS 259: Security Modeling and Analysis</li>
<li>CS 261: Optimization and Algorithmic Paradigms</li>
<li>CS 340: Networked Systems for Virtual Worlds</li>
<li>CS 344: Building an Internet Router</li>
<li>CS 355: Topics in Cryptography</li>
<li>CS 365: Randomized Algorithms</li>
</ul>


<p>c. Sufficient additional units selected from (b) and the following: CS 240E, 244E, 245, 294S<em>, 295, 341, 344B, 345, 347, 361A, 393</em>, 395<em>, 399</em>, EE 384A, 384B, 384C, 384M, 384S, 384X, 384Y</p>

<ul>
<li>CS 240E: Embedded Wireless Systems</li>
<li>CS 244E: Wireless Networking</li>
<li>CS 245: Database System Principles</li>
<li>CS 294S: Paradigm Shifts in Mobile and Social Computing Systems</li>
<li>CS 295: Software Engineering</li>
<li>CS 341: Project in Mining Massive Data Sets</li>
<li>CS 344B: Advanced Topics in Distributed Systems</li>
<li>CS 345: Advanced Topics in Database Systems</li>
<li>CS 347: Parallel and Distributed Data Management</li>
<li>CS 361A: Advanced Algorithms</li>
<li>CS 393: Computer Laboratory</li>
<li>CS 395: Independent Database Project</li>
<li>CS 399: Independent Project</li>
<li>EE 384A: Internet Routing Protocols and Standards</li>
<li>EE 384B: Mutimedia Communication over the Internet</li>
<li>EE 384C: Wireless Local Area Networks</li>
<li>EE 384M: Network Algorithms</li>
<li>EE 384S: Network Architectures and Performance Engineering</li>
<li>EE 384X: Packet Switch Architectures I</li>
<li>EE 384Y: Packet Switch Architectures II</li>
</ul>

]]></content>
  </entry>
  
</feed>
