<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: network | nameless]]></title>
  <link href="http://khakimov.github.com/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2014-08-17T18:06:23-07:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EventMachine. Day 4]]></title>
    <link href="http://khakimov.github.com/blog/2012/04/24/eventmachine-day-4/"/>
    <updated>2012-04-24T10:44:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/04/24/eventmachine-day-4</id>
    <content type="html"><![CDATA[<p>I'm at MiniService for regular routine, drinking coffee and reading this article <a href="http://ninjasandrobots.com/you-need-some-experience">I have no idea what I'm doing</a> and after I read it the only one I wanna say <em>I'll figure this out. And you will too =)</em>. Let's start!</p>

<p>Yesterday we stoped at <em>EM::Iterator.new(0..100, 50).each</em> and realized if we change it to <em>EM::Iterator.new(0..100000, 50).each</em> then it doesn't work well, probably generate thousand request in the same time and overflow the network.</p>

<p>I rewrite client.rb and now it looks better I think (tested on localhost):</p>

<p>``` ruby client.rb
require 'eventmachine'
require 'em-http'</p>

<p>urls = []</p>

<h1>File.open("1.csv", 'r') do |f|</h1>

<h1>while(line = f.gets)</h1>

<h1>urls &lt;&lt; "http://" + line.split(",")[1].strip</h1>

<h1>end</h1>

<h1>end</h1>

<p>EM.kqueue = true
successes = 0
failures = 0
count_connection = 0
total_connection = 0
t1 = Time.now</p>

<p>EM.run do
  url = "http://127.0.0.1"
  connect = proc {</p>

<pre><code>if count_connection &lt; 50
  # url = urls.pop
  http = EM::HttpRequest.new(url, :connect_timeout =&gt; 3, :inactivity_timeout =&gt; 5).get

  http.callback { 
    p "current connection: #{count_connection} vs #{EM::connection_count()}, total: #{total_connection}"
    count_connection -= 1
    successes += 1
    }

  http.errback { 
    count_connection -= 1
    failures += 1
    }

  total_connection += 1
  count_connection += 1
  EM.stop if total_connection &gt; 10000
end

EM.next_tick(&amp;connect)
</code></pre>

<p>  }
  count_connection += 1
  EM.next_tick(&amp;connect)<br/>
end
t2 = Time.now</p>

<p>p "Total #{total_connection}, #{successes} successful, #{failures} failures in #{t2 - t1}s"
```</p>

<p>I'm using callback and recursion, so when I get http.callback program start next connection until I get current_connection &lt; 50.</p>

<p><code>
"current connection: 5 vs 7, total: 9996"
"current connection: 5 vs 7, total: 9997"
"current connection: 5 vs 7, total: 9998"
"current connection: 5 vs 7, total: 9999"
"current connection: 5 vs 7, total: 10000"
"current connection: 5 vs 7, total: 10001"
"Total 10001, 9996 successful, 4 failures in 5.736506s"
</code></p>

<p>Sounds good, I've installed nginx on remote server in internet (just change url = "http://127.0.0.1" to url = "http://webserver") and as a test ran with 100 connections. And got a nice picture <strong>"Total 10001, 9872 successful, 128 failures in 113.439425s"</strong> and this is not the end, look at the network monitor:</p>

<p><img src="http://pix.am/C1kb.png" alt="" /></p>

<p>Yes! I used full network channel to get responses from my server. Looks like the end of the story, isn't? Stop, let's test it with our 1_000_000 webservers. Got this and don't know why yet:</p>

<p><code>
"current connection: 9 vs 11, total: 176, 158 successful, 8 failures"
"current connection: 9 vs 11, total: 177, 159 successful, 8 failures"
"current connection: 8 vs 11, total: 178, 161 successful, 8 failures"
"current connection: 9 vs 10, total: 179, 161 successful, 8 failures"
"current connection: 10 vs 11, total: 180, 161 successful, 8 failures"
</code></p>

<p>Looks like it works only with 10 connection in the same time and don't increase it, why is it possible I don't know yet. The only one idea about dns resolver. I'm going to read and will back to fight tomorrow!</p>
]]></content>
  </entry>
  
</feed>
