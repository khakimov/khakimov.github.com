<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | curious and driven]]></title>
  <link href="http://khakimov.github.com/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://khakimov.github.com/"/>
  <updated>2013-09-27T22:15:37-07:00</updated>
  <id>http://khakimov.github.com/</id>
  <author>
    <name><![CDATA[khakimov]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Playing with Rails]]></title>
    <link href="http://khakimov.github.com/blog/2012/05/07/playing-with-rails/"/>
    <updated>2012-05-07T23:55:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/05/07/playing-with-rails</id>
    <content type="html"><![CDATA[<p>Only with Rails I've realized meaning of the word REST and how RESTful Controller works. When you will understand CRUD and Scaffolding, you will easily create simple application, like one more blog or twitter clone ;)</p>

<p>CRUD = CREATE, SELECT, UPDATE, DELETE in database and create, show, update and destroy in Rails.</p>

<p>When we are using create HTTP sends POST request. For destroy - DELETE request. update - PUT and show simple GET. This is very useful, because you don't need to create different paths for object you going to work with. For example,</p>

<ul>
<li>create - will send POST /users</li>
<li>update - will send PUT /users/1</li>
<li>destroy - will send DELETE /users/1</li>
<li>show - will send /users/1</li>
</ul>


<p>I haven't seen this in Django, only with Rails realized this simplicity of REST.</p>

<p>I know, I know what already exists a tons of tutorials with Rails, but because it's good to repeat some fundomental stuff I'm also going to create one more. I'm going to build simple application called <strong>Morning Pages</strong>. I read the book <em>Pragmatic Thinking and Learning</em> and author describes one technic with same name "Morning Pages" when you wake up and start writing just random things from your head.</p>

<p><img src="http://pix.am/CuqHl.png" alt="" /></p>

<p>Specs:
morning page has title, body, created and updated time.</p>

<p>We want to be able:</p>

<ul>
<li>add new morning page</li>
<li>edit morning page</li>
<li>delete morning page</li>
<li>show morning page</li>
</ul>


<p>Let's start:</p>

<p>```
rails new morning_page</p>

<h1>here is trick with <a href="http://stackoverflow.com/questions/646951/singular-or-plural-controller-and-helper-names-in-rails">plural and singular</a>.</h1>

<p>rails generate controller MorningPages
rails generate model MorningPage title:string body:text</p>

<p>rake db:migrate
```</p>

<p>I'm not using scaffold here, because I think will be better to go throught step-by-step will be better to understand how it works. Scanffolding allows you create</p>

<ul>
<li>4 views (index, show, new and edit)</li>
<li>a layout file for all of those views</li>
<li>a stylesheet for all of those views</li>
<li>a model</li>
<li>a data migration to establish the tables needed for the model</li>
<li>a controller to send data</li>
<li>an empty file for helper methods</li>
<li>a new route that will map user requests to the controller</li>
</ul>


<p>a lot isnt's? but we are not looking for easy way ;) of course when you will understand how each part works, you can use scaffold. In our case we already created controller MorningPage and model with same name. Now I'm going insert some test data in a database. Open db/seed.db and add few records:</p>

<p><code>ruby seed.db
puts "Create few records"
MorningPage.create(title: 'Day 1', body: 'Good morning! Sunny day!')
MorningPage.create(title: 'Day 2', body: 'Hello! Such a wonderful day.')
</code></p>

<p><strong>seed.db</strong> is just a ruby script, so you can write here anything you want in ruby like cycles, parsing method or whatever. Then you should run <strong>rake db:seed</strong> to execute your's seed.db. Ok, nice, now we have two records in our database and we can also check this with rails console</p>

<p>```
khakimov in ~/Projects/current/ruby/rails/rails_app/morning on master
± rails console
Loading development environment (Rails 3.2.3)</p>

<blockquote><blockquote><p>MorningPage.all()
=> [#<MorningPage id: 1, title: "Day 1", body: "Good morning! Sunny day!", created_at: "2012-05-08 23:29:58", updated_at: "2012-05-09 20:50:56">, ...]
```</p></blockquote></blockquote>

<p>so far, so good with model. move on to controller. We don't have any action methods yet, like index, show, edit... Open app/controllers/morning_pages_controller.rb and add index, show, new, edit, create, update and destroy:</p>

<p>``` ruby morining_page_controller.rb
class MorningPagesController &lt; ApplicationController</p>

<pre><code>def index
    @messages = MorningPage.all()
end

def show
    @message = MorningPage.find(params[:id])
end

def new
end

def edit
    @morning_page = MorningPage.find(params[:id])
end

def create
    #logger.debug(params)
    @morning_page = MorningPage.new(params[:morning_page])

    if @morning_page.save
        redirect_to @morning_page
    else
        render :action =&gt; "new"
    end

end

def update
    @morning_page = MorningPage.find(params[:id])

    if @morning_page.update_attributes(params[:morning_page])
        redirect_to @morning_page
    else
        render :action =&gt; :edit
    end
end

def destroy
    @morning_page = MorningPage.find(params[:id])

    if @morning_page.destroy
        redirect_to morning_page_index_path
    else
        render :action =&gt; :index, :notice =&gt; "fail"
    end
end
</code></pre>

<p>end
```</p>

<p>in our config/routes.rb file don't forget to add which will allow route request to the methods</p>

<p>```
  root :to => 'morning_pages#index'</p>

<p>  resources :morning_pages
```</p>

<p>ok, now our application can route request, but we can't check it without layouts. So, create views/morning_pages/ with files:</p>

<p>``` html edit.html.erb</p>

<ul class="content">
<%= form_for(@morning_page, :url => {:action => :update}) do |f| %>
    <li class="text_field">
        <%= f.label :title %>
        <%= f.text_field :title, :placeholder => 'Title', :size => 'auto' %>
    </li>

    <li class="text_field">
        <%= f.label :body %><br />
        <%= f.text_area :body, :placeholder => 'Body' %><br />
    </li>
    <%= f.submit "Modify Page", :class => "buttonize submit_form", :id => 'form_submitter' %>

<% end %>
</ul>


<p>```</p>

<p>``` html index.html.erb</p>

<ul class="content home clearfix users">

<% if !@messages.blank? %>
  <% for item in @messages %>
    <li class="post clearfix <%= cycle('jared','daslee')%>">
        <p class="title">
          <%= item.updated_at.to_formatted_s(:long) %>
          <%= link_to(item.title, morning_page_path(item), :class => 'clearfix') %> 
          <%= link_to("edit", edit_morning_page_path(item)) %> |
          <%= link_to("delete", morning_page_path(item), 
              :confirm => 'Are you sure?', :method => :delete) %>
      </p>
    </li>
  <% end %>
<% else %>
  
<% end %>
    <li class="post clearfix"></li>
</ul>


<p>```</p>

<p>``` html new.html.erb</p>

<ul class="content">
<%= form_for(:morning_page, :url => {:action => :create}) do |f| %>
    <li class="text_field">
        <%= f.label :title %>
        <%= f.text_field :title, :placeholder => 'Title', :size => 'auto' %>
    </li>

    <li class="text_field">
        <%= f.label :body %><br />
        <%= f.text_area :body, :placeholder => 'Body' %><br />
    </li>
    <%= f.submit "Save Page", :class => "buttonize submit_form", :id => 'form_submitter' %>

<% end %>
</ul>


<p>```</p>

<p>``` html show.html.erb</p>

<ul class="content">
    <li class="text_field">
        <label for="morning_page_title">Title</label>
            <p><%= @message.title%><br/></p>
    </li>
    <li class="text_field">
        <label for="morning_page_title">Body</label>
        <p><%= @message.body %></p>
    </li>
</ul>


<p>```</p>

<p>It's very hard to describe how to do something, how to build, that's why probably will be better just to check source code or build by you own without copy/paste tutorials. I'm sure that many beginers and not only beginners stuck with ideas, they don't want to build one more blog and this is idea not motivate to code and practice. When you really want to build something, that is the best period to practice and learn stuff, especially if you are doing this with somebody together. A lot of people looking for "weekend" project or to build something and hack with other, but the only place where they can find it is github. Github is good, but how to find in thousands project something simple and interesting for beginers? Will think about this, looks like an interesting idea.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EventMachine and WebSockets]]></title>
    <link href="http://khakimov.github.com/blog/2012/04/30/eventmachine-and-websockets/"/>
    <updated>2012-04-30T18:46:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/04/30/eventmachine-and-websockets</id>
    <content type="html"><![CDATA[<p>Few days couldn't use mt keyboard because fell of my bike and hurt my arms. Still using only one hand and that's enough to start doing some epic code ;) Today I'm going to start exploring world of websockets when you can send data from server to client's browser. Two things required - eventmachine as usual and em-websocket (<em>gem install em-websocket</em>)</p>

<p>The simplest echo server/client:</p>

<p>``` ruby
require 'eventmachine'
require 'em-websocket'</p>

<p>EM.run do
  puts "Server started on 127.0.0.1:4000 (open index.html in your browser)"
  EM::WebSocket.start(:host => '127.0.0.1', :port => 4000) do |websocket|</p>

<pre><code>websocket.onopen { puts "Client connected" }
websocket.onmessage do |msg|
  p msg
  websocket.send(msg)
end
</code></pre>

<p>  end
end
```</p>

<p>``` html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"></p>

<p><html lang="en">
<head></p>

<pre><code>&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;
&lt;title&gt;index&lt;/title&gt;
&lt;script src='https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js'&gt;&lt;/script&gt;
&lt;script&gt;
  var ws;

  $(document).ready(function()
  {
    if (!("WebSocket" in window))
    {
      alert("Sorry, WebSockets unavailable.");
      return;
    }

    ws = new WebSocket("ws://127.0.0.1:4000/");

    ws.onopen = function() {
        console.log("connected...");
        ws.send("hello server");
        ws.send("hello again");  
    };
    ws.onmessage = function(evt)
    {
        console.log(evt);
        $('#echo').append(evt.data +"&lt;br&gt;");
    };

    ws.onclose = function()
    {
      console.log("socket closed");
    };
});
&lt;/script&gt;
</code></pre>

<p></head></p>

<pre><code>&lt;body&gt;
    meh
    &lt;div id="echo"&gt;&lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p></html>
```</p>

<h2>websocket client side</h2>

<ul>
<li><strong>ws = new WebSocket("ws://127.0.0.1:4000/");</strong> create WebSocket object</li>
<li><strong>onopen</strong> - call it when a socket has opened</li>
<li><strong>onmessage</strong> - call it when a message has been received</li>
<li><strong>onclose</strong> - when a socket has been closed</li>
</ul>


<h2>websocket server side</h2>

<ul>
<li><strong>EM::WebSocket.start(:host => '127.0.0.1', :port => 4000) do |websocket|</strong> open and listen requests on port 4000</li>
<li><strong>onopen</strong> - call it when a socket has opened</li>
<li><strong>onmessage</strong> - call it when a message has been received</li>
<li><strong>onclose</strong> - when a socket has been closed</li>
</ul>


<p>Let's play a little bit with websocket and our last project that scans websites and gets <strong>header</strong> (I'm really n00b with frontend stuff, so, don't judge me)</p>

<p>``` html
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd"></p>

<p><html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <title>index</title>
  <meta name="author" content="Ruslan Khakimov">
  <script src='http://127.0.0.1:3000/jquery-1.7.2.js'></script></p>

<pre><code>&lt;script&gt;
  var ws;

  $(document).ready(function()
  {
    if (!("WebSocket" in window))
    {
      alert("Sorry, WebSockets unavailable.");
      return;
    }

    ws = new WebSocket("ws://127.0.0.1:8080/");

    ws.onopen = function() {
        console.log("connected...");
    };

    ws.onmessage = function(evt)
    {
        data = JSON.parse(evt.data);
        nginx = data.nginx;
        apache = data.apache;
        ms = data.ms; 
        total = nginx + apache + ms;

        render_star('nginx', nginx/total * 100);
        render_star('apache', apache/total * 100);
        render_star('ms', ms/total * 100);

    };

    ws.onclose = function()
    {
      console.log("socket closed");
    };

    function render_star(name, num){
      $('#' + name).html('');
      for(var i =0; i&lt; num; i++) {
        $('#'+ name).append('*');
      }

    };

});
&lt;/script&gt;
</code></pre>

<p></head>
<body></p>

<p>  <div id="test"></p>

<pre><code>nginx: &lt;div id="nginx"&gt;&lt;/div&gt;
apache: &lt;div id="apache"&gt;&lt;/div&gt;
ms: &lt;div id="ms"&gt;&lt;/div&gt;
</code></pre>

<p>  </div></p>

<p></body>
</html>
```</p>

<p>and server:
``` ruby server.rb
require 'eventmachine'
require "em-websocket"
require "json"</p>

<p>module EventMachine
  module DNS</p>

<pre><code>class Request
  def initialize(socket, hostname)
    @socket = socket
    @hostname = hostname
    @tries = 0
    @last_send = Time.at(0)
    @retry_interval = 3
    @max_tries = 5

    if addrs = Resolver.hosts[hostname]
      info = {"domain"=&gt; @hostname, "ips" =&gt; addrs}
      succeed info
    else
      EM.next_tick { tick }
    end
  end

  def receive_answer(msg)
    addrs = []
    msg.each_answer do |name,ttl,data|
      if data.kind_of?(Resolv::DNS::Resource::IN::A) ||
          data.kind_of?(Resolv::DNS::Resource::IN::AAAA)
        addrs &lt;&lt; data.address.to_s
      end
    end

    if addrs.empty?
      fail "rcode=#{msg.rcode}, #{@hostname}"
    else
      info = {"domain"=&gt; @hostname, "ips" =&gt; addrs}
      succeed info
    end
  end
end
</code></pre>

<p>  end
end</p>

<p>urls = []</p>

<p>File.open("1.csv", 'r') do |f|
  while(line = f.gets)</p>

<pre><code>urls &lt;&lt; line.split(",")[1].strip
</code></pre>

<p>  end
end</p>

<p>class Client &lt; EM::Connection
  @@webserver_stats = {"nginx" => 0, "apache" => 0, "ms" => 0}</p>

<p>  def initialize domain, channel</p>

<pre><code>@domain = domain
comm_inactivity_timeout = 3
pending_connect_timeout = 5
@channel = channel
</code></pre>

<p>  end</p>

<p>  def post_init</p>

<pre><code>send_data "GET / HTTP/1.1\r\nHost: #{@domain}\r\n\r\n"
</code></pre>

<p>  end</p>

<p>  # Parse answer from webserver and count stats
  def receive_data data</p>

<pre><code>data =~ /Server: ([^\r\n]*)/
webserver = $1
case webserver
when /nginx/      then  @@webserver_stats.merge({"nginx" =&gt; @@webserver_stats['nginx'] += 1})
when /Apache/     then  @@webserver_stats.merge({"apache" =&gt; @@webserver_stats['apache'] += 1})
when /Microsoft/  then  @@webserver_stats.merge({"ms" =&gt; @@webserver_stats['ms'] += 1})
end
p webserver
@channel.push @@webserver_stats

close_connection
</code></pre>

<p>  end</p>

<p>end</p>

<p>successes = 0
failures = 0
total_connection = 0
t1 = Time.now
urls_size = urls.size</p>

<p>EM.run do</p>

<p>@channel = EM::Channel.new</p>

<p>  connect = proc {</p>

<pre><code>if EM::connection_count() &lt; 300
  url = urls.pop
  dns = EM::DNS::Resolver.resolve url

  dns.callback {|data|
    successes += 1
    EM.connect data["ips"][0], 80, Client, data["domain"], @channel unless data["ips"][0].nil?
  }

  dns.errback { |data| failures += 1 }

  total_connection += 1
end

if total_connection &lt; urls_size 
  EM.add_timer(1) { EM.next_tick(&amp;connect) }  #originaly here should be something like 0.002, but this is test
else
  EM.add_timer(5) {EM.stop}   # 5 seconds timer to lets finish slow connections
end
</code></pre>

<p>  }</p>

<p>  EM.next_tick(&amp;connect)</p>

<p>  # print stats with progress every 3 seconds
  stats = proc {</p>

<pre><code>  p "current connection: #{EM::connection_count()}, total: #{total_connection}, #{successes}\
    successful, #{failures} failures, #{ (successes / (Time.now - t1)).to_i} domains/sec"
  EM.add_timer 3, &amp;stats
</code></pre>

<p>  }
  EM.add_timer 3, &amp;stats</p>

<p>  # starts websocket server
  EM::WebSocket.start(:host => "127.0.0.1", :port => 8080, :debug => false) do |ws|</p>

<p>  ws.onopen {</p>

<pre><code>sid = @channel.subscribe { |msg| ws.send msg.to_json }

ws.onclose {
  @channel.unsubscribe(sid)
}
</code></pre>

<p>  }
  end
end</p>

<p>t2 = Time.now
p "Total #{total_connection}, #{successes} successful, #{failures} failures in #{t2 - t1}s"
```
...few days of repairing after bike crash...</p>

<p>Thats how simple using websockets is, and combined with eventmachine, they can be pretty awesome together. This is the end of my journey with EM for this time and I'm going to improve some skills with Rails. Let me know on email ruslan@&lt;%= current_domain_name %> if you have any question about eventmachine.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Rails project: Thoughts]]></title>
    <link href="http://khakimov.github.com/blog/2012/04/14/first-rails-project-thoughts/"/>
    <updated>2012-04-14T22:06:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/04/14/first-rails-project-thoughts</id>
    <content type="html"><![CDATA[<p>Huh, long time no post there. I've been in LA, spent last weekend at the Santa Monica beach, was at few Hollywood clubs, bars and restaurants, drank some wine, beer, white russian and even sake. Whole week was disconnected and didn't touch laptop (confess, only hackernews), so now I'm really ready back to the big fight. So, I came back from airport and in few hours finished my first small project on Rails.</p>

<p><img src="http://distilleryimage6.s3.amazonaws.com/72f5c216810511e1a39b1231381b7ba1_7.jpg" alt="Santa Monica beach" /></p>

<h2>idea</h2>

<p>I just built the place where I can put my thoughts with timeline. Possibly I'll add questions about any sphere of our lives, like <em>"What do you think about love?"</em> or <em>"What do you think about your age?"</em> and look at the progress with my thoughts through time. Everything changing in our world and my thoughts are not exception, so I want to look at the progress and how it is changing. Anyway, first version is <a href="http://hollow-flower-2767.herokuapp.com/users/1/timelines#4">here</a>:</p>

<p><img src="http://pix.am/bJ5h.png" alt="" /></p>

<h2>technology</h2>

<p>I've used js library <a href="http://timeline.verite.co/">timeline</a> as a core and implement it to work with rails.</p>

<blockquote><ul>
<li>Full stack:

<ul>
<li>ruby on rails</li>
<li><a href="https://github.com/plataformatec/devise">devise - Flexible authentication solution for Rails</a></li>
<li><a href="http://timeline.verite.co/">timeline js library</a></li>
<li>jquery</li>
<li><a href="http://twitter.github.com/bootstrap/">twitter bootstrap</a></li>
<li>heroku</li>
</ul>
</li>
</ul>
</blockquote>

<h2>bugs</h2>

<p>Yea, a lot of bugs and roughness with ui, html, css and js. Currently my priority are just code the ruby code and practice with rails and not stuck with js/html/css/design. I'm always thinking about perfection and that was a reason heretofore why I gave up with many ideas and hobbies, I didn't realize one small but very valuable thing - as a beginner you can't do everything perfect. I always compared my code with some opensource project and it was always reason for melancholy, because I though that my code worst ever and I will never able to build something by myself. But the path of trial and error showed me the truth - just practice and focus on one thing.</p>

<h2><a href="http://hollow-flower-2767.herokuapp.com/users/1/timelines#4">My thoughts timeline</a></h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[tips and tricks]]></title>
    <link href="http://khakimov.github.com/blog/2012/03/15/tips-and-tricks/"/>
    <updated>2012-03-15T17:15:00-07:00</updated>
    <id>http://khakimov.github.com/blog/2012/03/15/tips-and-tricks</id>
    <content type="html"><![CDATA[<p>Class methods are usually called with the double colon.</p>

<p>The respond_to? method is really nice and I plead that you never forget
it’s there. The respond_to? checks any object to be sure that it has a
certain method. It then gives back a true or false.</p>

<p>.collect keeps the answer the block gives back and adds it to a new
Array. The collect method is the perfect way of building a new Array
which is based on the items in an existing Array.</p>

<p>Always remember that a Module is only an inn. A roof over their heads.
It is not a self-aware Class and, therefore, cannot be brought to life
with new.</p>

<p>``` ruby
class SkatingContest
   def the_winner; @the_winner; end
   def the_winner=( name )</p>

<pre><code> unless name.respond_to? :to_str
   raise ArgumentError, "The winner's name must be a String,
     not a math problem or a list of names or any of that business." 
 end
 @the_winner = name
</code></pre>

<p>   end
 end
```</p>

<h1>Adding reference column:</h1>

<p>When you are modifying an existing table then references will not work. And actually, it is not really necessary when integer will work just as well.</p>

<p>I'd say the advantage of using references instead of a plain integer is that the model will be predefined with belongs_to and since the model is already created and will not be affected when you migrate something existing, the purpose is kind of lost.</p>

<p>So I would do like this instead:</p>

<p><code>
rails g migration add_user_id_to_tester user_id:integer
</code></p>

<p>And then manually add belongs_to :user in the Tester model</p>
]]></content>
  </entry>
  
</feed>
